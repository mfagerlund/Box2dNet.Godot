// Generated by Box2dWrap for Box2D v3 on 17/11/2024 12:23:50

using System.Runtime.InteropServices;
using System.Numerics;

// ReSharper disable InconsistentNaming

namespace Box2dNet.Interop
{

public enum b2TOIState
{

  b2_toiStateUnknown,

  b2_toiStateFailed,

  b2_toiStateOverlapped,

  b2_toiStateHit,
}

public enum b2MixingRule
{

  b2_mixAverage,

  b2_mixGeometricMean,

  b2_mixMultiply,

  b2_mixMinimum,
}

public enum b2BodyType
{

  /// <summary>
  /// zero mass, zero velocity, may be manually moved
  /// </summary>
  b2_staticBody = 0,

  /// <summary>
  /// zero mass, velocity set by user, moved by solver
  /// </summary>
  b2_kinematicBody = 1,

  /// <summary>
  /// positive mass, velocity determined by forces, moved by solver
  /// </summary>
  b2_dynamicBody = 2,

  /// <summary>
  /// number of body types
  /// </summary>
  b2_bodyTypeCount,
}

public enum b2ShapeType
{

  /// <summary>
  /// A circle with an offset
  /// </summary>
  b2_circleShape,

  /// <summary>
  /// A capsule is an extruded circle
  /// </summary>
  b2_capsuleShape,

  /// <summary>
  /// A line segment
  /// </summary>
  b2_segmentShape,

  /// <summary>
  /// A convex polygon
  /// </summary>
  b2_polygonShape,

  /// <summary>
  /// A line segment owned by a chain shape
  /// </summary>
  b2_chainSegmentShape,
}

public enum b2JointType
{

  b2_distanceJoint,

  b2_motorJoint,

  b2_mouseJoint,

  b2_nullJoint,

  b2_prismaticJoint,

  b2_revoluteJoint,

  b2_weldJoint,

  b2_wheelJoint,
}

public enum b2HexColor
{

  b2_colorAliceBlue = 0xf0f8ff,

  b2_colorAntiqueWhite = 0xfaebd7,

  b2_colorAquamarine = 0x7fffd4,

  b2_colorAzure = 0xf0ffff,

  b2_colorBeige = 0xf5f5dc,

  b2_colorBisque = 0xffe4c4,

  b2_colorBlack = 0x000000,

  b2_colorBlanchedAlmond = 0xffebcd,

  b2_colorBlue = 0x0000ff,

  b2_colorBlueViolet = 0x8a2be2,

  b2_colorBrown = 0xa52a2a,

  b2_colorBurlywood = 0xdeb887,

  b2_colorCadetBlue = 0x5f9ea0,

  b2_colorChartreuse = 0x7fff00,

  b2_colorChocolate = 0xd2691e,

  b2_colorCoral = 0xff7f50,

  b2_colorCornflowerBlue = 0x6495ed,

  b2_colorCornsilk = 0xfff8dc,

  b2_colorCrimson = 0xdc143c,

  b2_colorCyan = 0x00ffff,

  b2_colorDarkBlue = 0x00008b,

  b2_colorDarkCyan = 0x008b8b,

  b2_colorDarkGoldenrod = 0xb8860b,

  b2_colorDarkGray = 0xa9a9a9,

  b2_colorDarkGreen = 0x006400,

  b2_colorDarkKhaki = 0xbdb76b,

  b2_colorDarkMagenta = 0x8b008b,

  b2_colorDarkOliveGreen = 0x556b2f,

  b2_colorDarkOrange = 0xff8c00,

  b2_colorDarkOrchid = 0x9932cc,

  b2_colorDarkRed = 0x8b0000,

  b2_colorDarkSalmon = 0xe9967a,

  b2_colorDarkSeaGreen = 0x8fbc8f,

  b2_colorDarkSlateBlue = 0x483d8b,

  b2_colorDarkSlateGray = 0x2f4f4f,

  b2_colorDarkTurquoise = 0x00ced1,

  b2_colorDarkViolet = 0x9400d3,

  b2_colorDeepPink = 0xff1493,

  b2_colorDeepSkyBlue = 0x00bfff,

  b2_colorDimGray = 0x696969,

  b2_colorDodgerBlue = 0x1e90ff,

  b2_colorFirebrick = 0xb22222,

  b2_colorFloralWhite = 0xfffaf0,

  b2_colorForestGreen = 0x228b22,

  b2_colorGainsboro = 0xdcdcdc,

  b2_colorGhostWhite = 0xf8f8ff,

  b2_colorGold = 0xffd700,

  b2_colorGoldenrod = 0xdaa520,

  b2_colorGray = 0xbebebe,

  b2_colorGray1 = 0x1a1a1a,

  b2_colorGray2 = 0x333333,

  b2_colorGray3 = 0x4d4d4d,

  b2_colorGray4 = 0x666666,

  b2_colorGray5 = 0x7f7f7f,

  b2_colorGray6 = 0x999999,

  b2_colorGray7 = 0xb3b3b3,

  b2_colorGray8 = 0xcccccc,

  b2_colorGray9 = 0xe5e5e5,

  b2_colorGreen = 0x00ff00,

  b2_colorGreenYellow = 0xadff2f,

  b2_colorHoneydew = 0xf0fff0,

  b2_colorHotPink = 0xff69b4,

  b2_colorIndianRed = 0xcd5c5c,

  b2_colorIndigo = 0x4b0082,

  b2_colorIvory = 0xfffff0,

  b2_colorKhaki = 0xf0e68c,

  b2_colorLavender = 0xe6e6fa,

  b2_colorLavenderBlush = 0xfff0f5,

  b2_colorLawnGreen = 0x7cfc00,

  b2_colorLemonChiffon = 0xfffacd,

  b2_colorLightBlue = 0xadd8e6,

  b2_colorLightCoral = 0xf08080,

  b2_colorLightCyan = 0xe0ffff,

  b2_colorLightGoldenrod = 0xeedd82,

  b2_colorLightGoldenrodYellow = 0xfafad2,

  b2_colorLightGray = 0xd3d3d3,

  b2_colorLightGreen = 0x90ee90,

  b2_colorLightPink = 0xffb6c1,

  b2_colorLightSalmon = 0xffa07a,

  b2_colorLightSeaGreen = 0x20b2aa,

  b2_colorLightSkyBlue = 0x87cefa,

  b2_colorLightSlateBlue = 0x8470ff,

  b2_colorLightSlateGray = 0x778899,

  b2_colorLightSteelBlue = 0xb0c4de,

  b2_colorLightYellow = 0xffffe0,

  b2_colorLimeGreen = 0x32cd32,

  b2_colorLinen = 0xfaf0e6,

  b2_colorMagenta = 0xff00ff,

  b2_colorMaroon = 0xb03060,

  b2_colorMediumAquamarine = 0x66cdaa,

  b2_colorMediumBlue = 0x0000cd,

  b2_colorMediumOrchid = 0xba55d3,

  b2_colorMediumPurple = 0x9370db,

  b2_colorMediumSeaGreen = 0x3cb371,

  b2_colorMediumSlateBlue = 0x7b68ee,

  b2_colorMediumSpringGreen = 0x00fa9a,

  b2_colorMediumTurquoise = 0x48d1cc,

  b2_colorMediumVioletRed = 0xc71585,

  b2_colorMidnightBlue = 0x191970,

  b2_colorMintCream = 0xf5fffa,

  b2_colorMistyRose = 0xffe4e1,

  b2_colorMoccasin = 0xffe4b5,

  b2_colorNavajoWhite = 0xffdead,

  b2_colorNavyBlue = 0x000080,

  b2_colorOldLace = 0xfdf5e6,

  b2_colorOlive = 0x808000,

  b2_colorOliveDrab = 0x6b8e23,

  b2_colorOrange = 0xffa500,

  b2_colorOrangeRed = 0xff4500,

  b2_colorOrchid = 0xda70d6,

  b2_colorPaleGoldenrod = 0xeee8aa,

  b2_colorPaleGreen = 0x98fb98,

  b2_colorPaleTurquoise = 0xafeeee,

  b2_colorPaleVioletRed = 0xdb7093,

  b2_colorPapayaWhip = 0xffefd5,

  b2_colorPeachPuff = 0xffdab9,

  b2_colorPeru = 0xcd853f,

  b2_colorPink = 0xffc0cb,

  b2_colorPlum = 0xdda0dd,

  b2_colorPowderBlue = 0xb0e0e6,

  b2_colorPurple = 0xa020f0,

  b2_colorRebeccaPurple = 0x663399,

  b2_colorRed = 0xff0000,

  b2_colorRosyBrown = 0xbc8f8f,

  b2_colorRoyalBlue = 0x4169e1,

  b2_colorSaddleBrown = 0x8b4513,

  b2_colorSalmon = 0xfa8072,

  b2_colorSandyBrown = 0xf4a460,

  b2_colorSeaGreen = 0x2e8b57,

  b2_colorSeashell = 0xfff5ee,

  b2_colorSienna = 0xa0522d,

  b2_colorSilver = 0xc0c0c0,

  b2_colorSkyBlue = 0x87ceeb,

  b2_colorSlateBlue = 0x6a5acd,

  b2_colorSlateGray = 0x708090,

  b2_colorSnow = 0xfffafa,

  b2_colorSpringGreen = 0x00ff7f,

  b2_colorSteelBlue = 0x4682b4,

  b2_colorTan = 0xd2b48c,

  b2_colorTeal = 0x008080,

  b2_colorThistle = 0xd8bfd8,

  b2_colorTomato = 0xff6347,

  b2_colorTurquoise = 0x40e0d0,

  b2_colorViolet = 0xee82ee,

  b2_colorVioletRed = 0xd02090,

  b2_colorWheat = 0xf5deb3,

  b2_colorWhite = 0xffffff,

  b2_colorWhiteSmoke = 0xf5f5f5,

  b2_colorYellow = 0xffff00,

  b2_colorYellowGreen = 0x9acd32,

  b2_colorBox2DRed = 0xdc3132,

  b2_colorBox2DBlue = 0x30aebf,

  b2_colorBox2DGreen = 0x8cc924,
}

  /// <summary>
  /// Prototype for user allocation function
  /// </summary>
  /// <param name="size">the allocation size in bytes</param>
  /// <param name="alignment">the required alignment, guaranteed to be a power of 2</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate IntPtr /* void* */ b2AllocFcn(uint size, int alignment);

  /// <summary>
  /// Prototype for user free function
  /// </summary>
  /// <param name="mem">the memory previously allocated through `b2AllocFcn`</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate void b2FreeFcn(IntPtr /* void* */ mem);

  /// <summary>
  /// Prototype for the user assert callback. Return 0 to skip the debugger break.
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate int b2AssertFcn(string condition, string fileName, int lineNumber);

  /// <summary>
  /// This function receives proxies found in the AABB query.
  /// @return true if the query should continue
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate bool b2TreeQueryCallbackFcn(int proxyId, int userData, IntPtr /* void* */ context);

  /// <summary>
  /// This function receives clipped ray cast input for a proxy. The function
  /// returns the new ray fraction.
  /// - return a value of 0 to terminate the ray cast
  /// - return a value less than input->maxFraction to clip the ray
  /// - return a value of input->maxFraction to continue the ray cast without clipping
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate float b2TreeRayCastCallbackFcn(in b2RayCastInput input, int proxyId, int userData, IntPtr /* void* */ context);

  /// <summary>
  /// This function receives clipped ray cast input for a proxy. The function
  /// returns the new ray fraction.
  /// - return a value of 0 to terminate the ray cast
  /// - return a value less than input->maxFraction to clip the ray
  /// - return a value of input->maxFraction to continue the ray cast without clipping
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate float b2TreeShapeCastCallbackFcn(in b2ShapeCastInput input, int proxyId, int userData, IntPtr /* void* */ context);

  /// <summary>
  /// Task interface
  /// This is prototype for a Box2D task. Your task system is expected to invoke the Box2D task with these arguments.
  /// The task spans a range of the parallel-for: [startIndex, endIndex)
  /// The worker index must correctly identify each worker in the user thread pool, expected in [0, workerCount).
  /// A worker must only exist on only one thread at a time and is analogous to the thread index.
  /// The task context is the context pointer sent from Box2D when it is enqueued.
  /// The startIndex and endIndex are expected in the range [0, itemCount) where itemCount is the argument to b2EnqueueTaskCallback
  /// below. Box2D expects startIndex < endIndex and will execute a loop like this:
  /// 
  /// @code{.c}
  /// for (int i = startIndex; i < endIndex; ++i)
  /// {
  /// DoWork();
  /// }
  /// @endcode
  /// @ingroup world
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate void b2TaskCallback(int startIndex, int endIndex, uint workerIndex, IntPtr /* void* */ taskContext);

  /// <summary>
  /// These functions can be provided to Box2D to invoke a task system. These are designed to work well with enkiTS.
  /// Returns a pointer to the user's task object. May be nullptr. A nullptr indicates to Box2D that the work was executed
  /// serially within the callback and there is no need to call b2FinishTaskCallback.
  /// The itemCount is the number of Box2D work items that are to be partitioned among workers by the user's task system.
  /// This is essentially a parallel-for. The minRange parameter is a suggestion of the minimum number of items to assign
  /// per worker to reduce overhead. For example, suppose the task is small and that itemCount is 16. A minRange of 8 suggests
  /// that your task system should split the work items among just two workers, even if you have more available.
  /// In general the range [startIndex, endIndex) send to b2TaskCallback should obey:
  /// endIndex - startIndex >= minRange
  /// The exception of course is when itemCount < minRange.
  /// @ingroup world
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate IntPtr /* void* */ b2EnqueueTaskCallback(IntPtr /* b2TaskCallback */ task, int itemCount, int minRange, IntPtr /* void* */ taskContext, IntPtr /* void* */ userContext);

  /// <summary>
  /// Finishes a user task object that wraps a Box2D task.
  /// @ingroup world
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate void b2FinishTaskCallback(IntPtr /* void* */ userTask, IntPtr /* void* */ userContext);

  /// <summary>
  /// Prototype for a contact filter callback.
  /// This is called when a contact pair is considered for collision. This allows you to
  /// perform custom logic to prevent collision between shapes. This is only called if
  /// one of the two shapes has custom filtering enabled. @see b2ShapeDef.
  /// Notes:
  /// - this function must be thread-safe
  /// - this is only called if one of the two shapes has enabled custom filtering
  /// - this is called only for awake dynamic bodies
  /// Return false if you want to disable the collision
  /// @warning Do not attempt to modify the world inside this callback
  /// @ingroup world
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate bool b2CustomFilterFcn(b2ShapeId shapeIdA, b2ShapeId shapeIdB, IntPtr /* void* */ context);

  /// <summary>
  /// Prototype for a pre-solve callback.
  /// This is called after a contact is updated. This allows you to inspect a
  /// contact before it goes to the solver. If you are careful, you can modify the
  /// contact manifold (e.g. modify the normal).
  /// Notes:
  /// - this function must be thread-safe
  /// - this is only called if the shape has enabled pre-solve events
  /// - this is called only for awake dynamic bodies
  /// - this is not called for sensors
  /// - the supplied manifold has impulse values from the previous step
  /// Return false if you want to disable the contact this step
  /// @warning Do not attempt to modify the world inside this callback
  /// @ingroup world
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate bool b2PreSolveFcn(b2ShapeId shapeIdA, b2ShapeId shapeIdB, ref b2Manifold manifold, IntPtr /* void* */ context);

  /// <summary>
  /// Prototype callback for overlap queries.
  /// Called for each shape found in the query.
  /// @see b2World_QueryAABB
  /// @return false to terminate the query.
  /// @ingroup world
  /// </summary>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate bool b2OverlapResultFcn(b2ShapeId shapeId, IntPtr /* void* */ context);

  /// <summary>
  /// Prototype callback for ray casts.
  /// Called for each shape found in the query. You control how the ray cast
  /// proceeds by returning a float:
  /// return -1: ignore this shape and continue
  /// return 0: terminate the ray cast
  /// return fraction: clip the ray to this point
  /// return 1: don't clip the ray and continue
  /// @return -1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue
  /// @see b2World_CastRay
  /// @ingroup world
  /// </summary>
  /// <param name="shapeId">the shape hit by the ray</param>
  /// <param name="point">the point of initial intersection</param>
  /// <param name="normal">the normal vector at the point of intersection</param>
  /// <param name="fraction">the fraction along the ray at the point of intersection</param>
  /// <param name="context">the user context</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate float b2CastResultFcn(b2ShapeId shapeId, Vector2 point, Vector2 normal, float fraction, IntPtr /* void* */ context);

  /// <summary>
  /// Version numbering scheme.
  /// See https://semver.org/
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Version
{

  /// <summary>
  /// Significant changes
  /// </summary>
  public int major;

  /// <summary>
  /// Incremental changes
  /// </summary>
  public int minor;

  /// <summary>
  /// Bug fixes
  /// </summary>
  public int revision;
}

  /// <summary>
  /// Low level ray cast input data
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2RayCastInput
{

  /// <summary>
  /// Start point of the ray cast
  /// </summary>
  public Vector2 origin;

  /// <summary>
  /// Translation of the ray cast
  /// </summary>
  public Vector2 translation;

  /// <summary>
  /// The maximum fraction of the translation to consider, typically 1
  /// </summary>
  public float maxFraction;
}

  /// <summary>
  /// Low level shape cast input in generic form. This allows casting an arbitrary point
  /// cloud wrap with a radius. For example, a circle is a single point with a non-zero radius.
  /// A capsule is two points with a non-zero radius. A box is four points with a zero radius.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ShapeCastInput
{

  /// <summary>
  /// A point cloud to cast
  /// </summary>
  [MarshalAs(UnmanagedType.ByValArray, SizeConst = B2Api.b2_maxPolygonVertices)]
  public Vector2[] points;

  /// <summary>
  /// The number of points
  /// </summary>
  public int count;

  /// <summary>
  /// The radius around the point cloud
  /// </summary>
  public float radius;

  /// <summary>
  /// The translation of the shape cast
  /// </summary>
  public Vector2 translation;

  /// <summary>
  /// The maximum fraction of the translation to consider, typically 1
  /// </summary>
  public float maxFraction;
}

  /// <summary>
  /// Low level ray cast or shape-cast output data
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2CastOutput
{

  /// <summary>
  /// The surface normal at the hit point
  /// </summary>
  public Vector2 normal;

  /// <summary>
  /// The surface hit point
  /// </summary>
  public Vector2 point;

  /// <summary>
  /// The fraction of the input translation at collision
  /// </summary>
  public float fraction;

  /// <summary>
  /// The number of iterations used
  /// </summary>
  public int iterations;

  /// <summary>
  /// Did the cast hit?
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool hit;
}

  /// <summary>
  /// This holds the mass data computed for a shape.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2MassData
{

  /// <summary>
  /// The mass of the shape, usually in kilograms.
  /// </summary>
  public float mass;

  /// <summary>
  /// The position of the shape's centroid relative to the shape's origin.
  /// </summary>
  public Vector2 center;

  /// <summary>
  /// The rotational inertia of the shape about the local origin.
  /// </summary>
  public float rotationalInertia;
}

  /// <summary>
  /// A solid circle
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Circle
{

  /// <summary>
  /// The local center
  /// </summary>
  public Vector2 center;

  /// <summary>
  /// The radius
  /// </summary>
  public float radius;
}

  /// <summary>
  /// A solid capsule can be viewed as two semicircles connected
  /// by a rectangle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Capsule
{

  /// <summary>
  /// Local center of the first semicircle
  /// </summary>
  public Vector2 center1;

  /// <summary>
  /// Local center of the second semicircle
  /// </summary>
  public Vector2 center2;

  /// <summary>
  /// The radius of the semicircles
  /// </summary>
  public float radius;
}

  /// <summary>
  /// A solid convex polygon. It is assumed that the interior of the polygon is to
  /// the left of each edge.
  /// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
  /// In most cases you should not need many vertices for a convex polygon.
  /// @warning DO NOT fill this out manually, instead use a helper function like
  /// b2MakePolygon or b2MakeBox.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Polygon
{

  /// <summary>
  /// The polygon vertices
  /// </summary>
  [MarshalAs(UnmanagedType.ByValArray, SizeConst = B2Api.b2_maxPolygonVertices)]
  public Vector2[] vertices;

  /// <summary>
  /// The outward normal vectors of the polygon sides
  /// </summary>
  [MarshalAs(UnmanagedType.ByValArray, SizeConst = B2Api.b2_maxPolygonVertices)]
  public Vector2[] normals;

  /// <summary>
  /// The centroid of the polygon
  /// </summary>
  public Vector2 centroid;

  /// <summary>
  /// The external radius for rounded polygons
  /// </summary>
  public float radius;

  /// <summary>
  /// The number of polygon vertices
  /// </summary>
  public int count;
}

  /// <summary>
  /// A line segment with two-sided collision.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Segment
{

  /// <summary>
  /// The first point
  /// </summary>
  public Vector2 point1;

  /// <summary>
  /// The second point
  /// </summary>
  public Vector2 point2;
}

  /// <summary>
  /// A line segment with one-sided collision. Only collides on the right side.
  /// Several of these are generated for a chain shape.
  /// ghost1 -> point1 -> point2 -> ghost2
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ChainSegment
{

  /// <summary>
  /// The tail ghost vertex
  /// </summary>
  public Vector2 ghost1;

  /// <summary>
  /// The line segment
  /// </summary>
  public b2Segment segment;

  /// <summary>
  /// The head ghost vertex
  /// </summary>
  public Vector2 ghost2;

  /// <summary>
  /// The owning chain shape index (internal usage only)
  /// </summary>
  public int chainId;
}

  /// <summary>
  /// A convex hull. Used to create convex polygons.
  /// @warning Do not modify these values directly, instead use b2ComputeHull()
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Hull
{

  /// <summary>
  /// The final points of the hull
  /// </summary>
  [MarshalAs(UnmanagedType.ByValArray, SizeConst = B2Api.b2_maxPolygonVertices)]
  public Vector2[] points;

  /// <summary>
  /// The number of points
  /// </summary>
  public int count;
}

  /// <summary>
  /// Result of computing the distance between two line segments
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2SegmentDistanceResult
{

  /// <summary>
  /// The closest point on the first segment
  /// </summary>
  public Vector2 closest1;

  /// <summary>
  /// The closest point on the second segment
  /// </summary>
  public Vector2 closest2;

  /// <summary>
  /// The barycentric coordinate on the first segment
  /// </summary>
  public float fraction1;

  /// <summary>
  /// The barycentric coordinate on the second segment
  /// </summary>
  public float fraction2;

  /// <summary>
  /// The squared distance between the closest points
  /// </summary>
  public float distanceSquared;
}

  /// <summary>
  /// A distance proxy is used by the GJK algorithm. It encapsulates any shape.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2DistanceProxy
{

  /// <summary>
  /// The point cloud
  /// </summary>
  [MarshalAs(UnmanagedType.ByValArray, SizeConst = B2Api.b2_maxPolygonVertices)]
  public Vector2[] points;

  /// <summary>
  /// The number of points
  /// </summary>
  public int count;

  /// <summary>
  /// The external radius of the point cloud
  /// </summary>
  public float radius;
}

  /// <summary>
  /// Input for b2ShapeDistance
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2DistanceInput
{

  /// <summary>
  /// The proxy for shape A
  /// </summary>
  public b2DistanceProxy proxyA;

  /// <summary>
  /// The proxy for shape B
  /// </summary>
  public b2DistanceProxy proxyB;

  /// <summary>
  /// The world transform for shape A
  /// </summary>
  public b2Transform transformA;

  /// <summary>
  /// The world transform for shape B
  /// </summary>
  public b2Transform transformB;

  /// <summary>
  /// Should the proxy radius be considered?
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool useRadii;
}

  /// <summary>
  /// Output for b2ShapeDistance
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2DistanceOutput
{

  /// <summary>
  /// Closest point on shapeA
  /// </summary>
  public Vector2 pointA;

  /// <summary>
  /// Closest point on shapeB
  /// </summary>
  public Vector2 pointB;

  /// <summary>
  /// The final distance, zero if overlapped
  /// </summary>
  public float distance;

  /// <summary>
  /// Number of GJK iterations used
  /// </summary>
  public int iterations;

  /// <summary>
  /// The number of simplexes stored in the simplex array
  /// </summary>
  public int simplexCount;
}

  /// <summary>
  /// Simplex vertex for debugging the GJK algorithm
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2SimplexVertex
{

  /// <summary>
  /// support point in proxyA
  /// </summary>
  public Vector2 wA;

  /// <summary>
  /// support point in proxyB
  /// </summary>
  public Vector2 wB;

  /// <summary>
  /// wB - wA
  /// </summary>
  public Vector2 w;

  /// <summary>
  /// barycentric coordinate for closest point
  /// </summary>
  public float a;

  /// <summary>
  /// wA index
  /// </summary>
  public int indexA;

  /// <summary>
  /// wB index
  /// </summary>
  public int indexB;
}

  /// <summary>
  /// Simplex from the GJK algorithm
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Simplex
{

  /// <summary>
  /// vertices
  /// </summary>
  public b2SimplexVertex v1, v2, v3;

  /// <summary>
  /// number of valid vertices
  /// </summary>
  public int count;
}

  /// <summary>
  /// Input parameters for b2ShapeCast
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ShapeCastPairInput
{

  /// <summary>
  /// The proxy for shape A
  /// </summary>
  public b2DistanceProxy proxyA;

  /// <summary>
  /// The proxy for shape B
  /// </summary>
  public b2DistanceProxy proxyB;

  /// <summary>
  /// The world transform for shape A
  /// </summary>
  public b2Transform transformA;

  /// <summary>
  /// The world transform for shape B
  /// </summary>
  public b2Transform transformB;

  /// <summary>
  /// The translation of shape B
  /// </summary>
  public Vector2 translationB;

  /// <summary>
  /// The fraction of the translation to consider, typically 1
  /// </summary>
  public float maxFraction;
}

  /// <summary>
  /// This describes the motion of a body/shape for TOI computation. Shapes are defined with respect to the body origin,
  /// which may not coincide with the center of mass. However, to support dynamics we must interpolate the center of mass
  /// position.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Sweep
{

  /// <summary>
  /// Local center of mass position
  /// </summary>
  public Vector2 localCenter;

  /// <summary>
  /// Starting center of mass world position
  /// </summary>
  public Vector2 c1;

  /// <summary>
  /// Ending center of mass world position
  /// </summary>
  public Vector2 c2;

  /// <summary>
  /// Starting world rotation
  /// </summary>
  public b2Rot q1;

  /// <summary>
  /// Ending world rotation
  /// </summary>
  public b2Rot q2;
}

  /// <summary>
  /// Input parameters for b2TimeOfImpact
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2TOIInput
{

  /// <summary>
  /// The proxy for shape A
  /// </summary>
  public b2DistanceProxy proxyA;

  /// <summary>
  /// The proxy for shape B
  /// </summary>
  public b2DistanceProxy proxyB;

  /// <summary>
  /// The movement of shape A
  /// </summary>
  public b2Sweep sweepA;

  /// <summary>
  /// The movement of shape B
  /// </summary>
  public b2Sweep sweepB;

  /// <summary>
  /// Defines the sweep interval [0, tMax]
  /// </summary>
  public float tMax;
}

  /// <summary>
  /// Output parameters for b2TimeOfImpact.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2TOIOutput
{

  /// <summary>
  /// The type of result
  /// </summary>
  public b2TOIState state;

  /// <summary>
  /// The time of the collision
  /// </summary>
  public float t;
}

  /// <summary>
  /// A manifold point is a contact point belonging to a contact
  /// manifold. It holds details related to the geometry and dynamics
  /// of the contact points.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ManifoldPoint
{

  /// <summary>
  /// Location of the contact point in world space. Subject to precision loss at large coordinates.
  /// @note Should only be used for debugging.
  /// </summary>
  public Vector2 point;

  /// <summary>
  /// Location of the contact point relative to bodyA's origin in world space
  /// @note When used internally to the Box2D solver, this is relative to the center of mass.
  /// </summary>
  public Vector2 anchorA;

  /// <summary>
  /// Location of the contact point relative to bodyB's origin in world space
  /// @note When used internally to the Box2D solver, this is relative to the center of mass.
  /// </summary>
  public Vector2 anchorB;

  /// <summary>
  /// The separation of the contact point, negative if penetrating
  /// </summary>
  public float separation;

  /// <summary>
  /// The impulse along the manifold normal vector.
  /// </summary>
  public float normalImpulse;

  /// <summary>
  /// The friction impulse
  /// </summary>
  public float tangentImpulse;

  /// <summary>
  /// The maximum normal impulse applied during sub-stepping
  /// This could be a bool to indicate the point is confirmed (may be a speculative point)
  /// </summary>
  public float maxNormalImpulse;

  /// <summary>
  /// Relative normal velocity pre-solve. Used for hit events. If the normal impulse is
  /// zero then there was no hit. Negative means shapes are approaching.
  /// </summary>
  public float normalVelocity;

  /// <summary>
  /// Uniquely identifies a contact point between two shapes
  /// </summary>
  public ushort id;

  /// <summary>
  /// Did this contact point exist the previous step?
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool persisted;
}

  /// <summary>
  /// A contact manifold describes the contact points between colliding shapes
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Manifold
{

  /// <summary>
  /// The manifold points, up to two are possible in 2D
  /// </summary>
  [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
  public b2ManifoldPoint[] points;

  /// <summary>
  /// The unit normal vector in world space, points from shape A to bodyB
  /// </summary>
  public Vector2 normal;

  /// <summary>
  /// The number of contacts points, will be 0, 1, or 2
  /// </summary>
  public int pointCount;
}

  /// <summary>
  /// These are performance results returned by dynamic tree queries.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2TreeStats
{

  /// <summary>
  /// Number of internal nodes visited during the query
  /// </summary>
  public int nodeVisits;

  /// <summary>
  /// Number of leaf nodes visited during the query
  /// </summary>
  public int leafVisits;
}

  /// <summary>
  /// World id references a world instance. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2WorldId
{

  public ushort index1;

  public ushort revision;
}

  /// <summary>
  /// Body id references a body instance. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2BodyId
{

  public int index1;

  public ushort world0;

  public ushort revision;
}

  /// <summary>
  /// Shape id references a shape instance. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ShapeId
{

  public int index1;

  public ushort world0;

  public ushort revision;
}

  /// <summary>
  /// Chain id references a chain instances. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ChainId
{

  public int index1;

  public ushort world0;

  public ushort revision;
}

  /// <summary>
  /// Joint id references a joint instance. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2JointId
{

  public int index1;

  public ushort world0;

  public ushort revision;
}

  /// <summary>
  /// Cosine and sine pair
  /// This uses a custom implementation designed for cross platform determinism
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2CosSin
{

  /// <summary>
  /// cosine and sine
  /// </summary>
  public float cosine;

  public float sine;
}

  /// <summary>
  /// 2D rotation
  /// This is similar to using a complex number for rotation
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Rot
{

  /// <summary>
  /// cosine and sine
  /// </summary>
  public float c, s;
}

  /// <summary>
  /// A 2D rigid transform
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Transform
{

  public Vector2 p;

  public b2Rot q;
}

  /// <summary>
  /// A 2-by-2 Matrix
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Mat22
{

  /// <summary>
  /// columns
  /// </summary>
  public Vector2 cx, cy;
}

  /// <summary>
  /// Axis-aligned bounding box
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2AABB
{

  public Vector2 lowerBound;

  public Vector2 upperBound;
}

  /// <summary>
  /// Result from b2World_RayCastClosest
  /// @ingroup world
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2RayResult
{

  public b2ShapeId shapeId;

  public Vector2 point;

  public Vector2 normal;

  public float fraction;

  public int nodeVisits;

  public int leafVisits;

  [MarshalAs(UnmanagedType.U1)]
  public bool hit;
}

  /// <summary>
  /// World definition used to create a simulation world.
  /// Must be initialized using b2DefaultWorldDef().
  /// @ingroup world
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2WorldDef
{

  /// <summary>
  /// Gravity vector. Box2D has no up-vector defined.
  /// </summary>
  public Vector2 gravity;

  /// <summary>
  /// Restitution velocity threshold, usually in m/s. Collisions above this
  /// speed have restitution applied (will bounce).
  /// </summary>
  public float restitutionThreshold;

  /// <summary>
  /// This parameter controls how fast overlap is resolved and has units of meters per second
  /// </summary>
  public float contactPushoutVelocity;

  /// <summary>
  /// Threshold velocity for hit events. Usually meters per second.
  /// </summary>
  public float hitEventThreshold;

  /// <summary>
  /// Contact stiffness. Cycles per second.
  /// </summary>
  public float contactHertz;

  /// <summary>
  /// Contact bounciness. Non-dimensional.
  /// </summary>
  public float contactDampingRatio;

  /// <summary>
  /// Joint stiffness. Cycles per second.
  /// </summary>
  public float jointHertz;

  /// <summary>
  /// Joint bounciness. Non-dimensional.
  /// </summary>
  public float jointDampingRatio;

  /// <summary>
  /// Maximum linear velocity. Usually meters per second.
  /// </summary>
  public float maximumLinearVelocity;

  /// <summary>
  /// Mixing rule for friction. Default is b2_mixGeometricMean.
  /// </summary>
  public b2MixingRule frictionMixingRule;

  /// <summary>
  /// Mixing rule for restitution. Default is b2_mixMaximum.
  /// </summary>
  public b2MixingRule restitutionMixingRule;

  /// <summary>
  /// Can bodies go to sleep to improve performance
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSleep;

  /// <summary>
  /// Enable continuous collision
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableContinuous;

  /// <summary>
  /// Number of workers to use with the provided task system. Box2D performs best when using only
  /// performance cores and accessing a single L2 cache. Efficiency cores and hyper-threading provide
  /// little benefit and may even harm performance.
  /// </summary>
  public int workerCount;

  /// <summary>
  /// Function to spawn tasks
  /// </summary>
  public IntPtr /* b2EnqueueTaskCallback */ enqueueTask;

  /// <summary>
  /// Function to finish a task
  /// </summary>
  public IntPtr /* b2FinishTaskCallback */ finishTask;

  /// <summary>
  /// User context that is provided to enqueueTask and finishTask
  /// </summary>
  public IntPtr /* void* */ userTaskContext;

  /// <summary>
  /// User data
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// A body definition holds all the data needed to construct a rigid body.
  /// You can safely re-use body definitions. Shapes are added to a body after construction.
  /// Body definitions are temporary objects used to bundle creation parameters.
  /// Must be initialized using b2DefaultBodyDef().
  /// @ingroup body
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2BodyDef
{

  /// <summary>
  /// The body type: static, kinematic, or dynamic.
  /// </summary>
  public b2BodyType type;

  /// <summary>
  /// The initial world position of the body. Bodies should be created with the desired position.
  /// @note Creating bodies at the origin and then moving them nearly doubles the cost of body creation, especially
  /// if the body is moved after shapes have been added.
  /// </summary>
  public Vector2 position;

  /// <summary>
  /// The initial world rotation of the body. Use b2MakeRot() if you have an angle.
  /// </summary>
  public b2Rot rotation;

  /// <summary>
  /// The initial linear velocity of the body's origin. Typically in meters per second.
  /// </summary>
  public Vector2 linearVelocity;

  /// <summary>
  /// The initial angular velocity of the body. Radians per second.
  /// </summary>
  public float angularVelocity;

  /// <summary>
  /// Linear damping is use to reduce the linear velocity. The damping parameter
  /// can be larger than 1 but the damping effect becomes sensitive to the
  /// time step when the damping parameter is large.
  /// Generally linear damping is undesirable because it makes objects move slowly
  /// as if they are floating.
  /// </summary>
  public float linearDamping;

  /// <summary>
  /// Angular damping is use to reduce the angular velocity. The damping parameter
  /// can be larger than 1.0f but the damping effect becomes sensitive to the
  /// time step when the damping parameter is large.
  /// Angular damping can be use slow down rotating bodies.
  /// </summary>
  public float angularDamping;

  /// <summary>
  /// Scale the gravity applied to this body. Non-dimensional.
  /// </summary>
  public float gravityScale;

  /// <summary>
  /// Sleep velocity threshold, default is 0.05 meter per second
  /// </summary>
  public float sleepThreshold;

  /// <summary>
  /// Use this to store application specific body data.
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Set this flag to false if this body should never fall asleep.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSleep;

  /// <summary>
  /// Is this body initially awake or sleeping?
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool isAwake;

  /// <summary>
  /// Should this body be prevented from rotating? Useful for characters.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool fixedRotation;

  /// <summary>
  /// Treat this body as high speed object that performs continuous collision detection
  /// against dynamic and kinematic bodies, but not other bullet bodies.
  /// @warning Bullets should be used sparingly. They are not a solution for general dynamic-versus-dynamic
  /// continuous collision. They may interfere with joint constraints.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool isBullet;

  /// <summary>
  /// Used to disable a body. A disabled body does not move or collide.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool isEnabled;

  /// <summary>
  /// This allows this body to bypass rotational speed limits. Should only be used
  /// for circular objects, like wheels.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool allowFastRotation;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// This is used to filter collision on shapes. It affects shape-vs-shape collision
  /// and shape-versus-query collision (such as b2World_CastRay).
  /// @ingroup shape
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Filter
{

  /// <summary>
  /// The collision category bits. Normally you would just set one bit. The category bits should
  /// represent your application object types. For example:
  /// @code{.cpp}
  /// enum MyCategories
  /// {
  /// Static  = 0x00000001,
  /// Dynamic = 0x00000002,
  /// Debris  = 0x00000004,
  /// Player  = 0x00000008,
  /// // etc
  /// };
  /// @endcode
  /// </summary>
  public UInt64 categoryBits;

  /// <summary>
  /// The collision mask bits. This states the categories that this
  /// shape would accept for collision.
  /// For example, you may want your player to only collide with static objects
  /// and other players.
  /// @code{.c}
  /// maskBits = Static | Player;
  /// @endcode
  /// </summary>
  public UInt64 maskBits;

  /// <summary>
  /// Collision groups allow a certain group of objects to never collide (negative)
  /// or always collide (positive). A group index of zero has no effect. Non-zero group filtering
  /// always wins against the mask bits.
  /// For example, you may want ragdolls to collide with other ragdolls but you don't want
  /// ragdoll self-collision. In this case you would give each ragdoll a unique negative group index
  /// and apply that group index to all shapes on the ragdoll.
  /// </summary>
  public int groupIndex;
}

  /// <summary>
  /// The query filter is used to filter collisions between queries and shapes. For example,
  /// you may want a ray-cast representing a projectile to hit players and the static environment
  /// but not debris.
  /// @ingroup shape
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2QueryFilter
{

  /// <summary>
  /// The collision category bits of this query. Normally you would just set one bit.
  /// </summary>
  public UInt64 categoryBits;

  /// <summary>
  /// The collision mask bits. This states the shape categories that this
  /// query would accept for collision.
  /// </summary>
  public UInt64 maskBits;
}

  /// <summary>
  /// Used to create a shape.
  /// This is a temporary object used to bundle shape creation parameters. You may use
  /// the same shape definition to create multiple shapes.
  /// Must be initialized using b2DefaultShapeDef().
  /// @ingroup shape
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ShapeDef
{

  /// <summary>
  /// Use this to store application specific shape data.
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// The Coulomb (dry) friction coefficient, usually in the range [0,1].
  /// </summary>
  public float friction;

  /// <summary>
  /// The restitution (bounce) usually in the range [0,1].
  /// </summary>
  public float restitution;

  /// <summary>
  /// The density, usually in kg/m^2.
  /// </summary>
  public float density;

  /// <summary>
  /// Collision filtering data.
  /// </summary>
  public b2Filter filter;

  /// <summary>
  /// Custom debug draw color.
  /// </summary>
  public uint customColor;

  /// <summary>
  /// A sensor shape generates overlap events but never generates a collision response.
  /// Sensors do not collide with other sensors and do not have continuous collision.
  /// Instead use a ray or shape cast for those scenarios.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool isSensor;

  /// <summary>
  /// Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSensorEvents;

  /// <summary>
  /// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableContactEvents;

  /// <summary>
  /// Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableHitEvents;

  /// <summary>
  /// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive
  /// and must be carefully handled due to threading. Ignored for sensors.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enablePreSolveEvents;

  /// <summary>
  /// Normally shapes on static bodies don't invoke contact creation when they are added to the world. This overrides
  /// that behavior and causes contact creation. This significantly slows down static body creation which can be important
  /// when there are many static shapes.
  /// This is implicitly always true for sensors, dynamic bodies, and kinematic bodies.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool invokeContactCreation;

  /// <summary>
  /// Should the body update the mass properties when this shape is created. Default is true.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool updateBodyMass;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// Used to create a chain of line segments. This is designed to eliminate ghost collisions with some limitations.
  /// - chains are one-sided
  /// - chains have no mass and should be used on static bodies
  /// - chains have a counter-clockwise winding order
  /// - chains are either a loop or open
  /// - a chain must have at least 4 points
  /// - the distance between any two points must be greater than b2_linearSlop
  /// - a chain shape should not self intersect (this is not validated)
  /// - an open chain shape has NO COLLISION on the first and final edge
  /// - you may overlap two open chains on their first three and/or last three points to get smooth collision
  /// - a chain shape creates multiple line segment shapes on the body
  /// https://en.wikipedia.org/wiki/Polygonal_chain
  /// Must be initialized using b2DefaultChainDef().
  /// @warning Do not use chain shapes unless you understand the limitations. This is an advanced feature.
  /// @ingroup shape
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ChainDef
{

  /// <summary>
  /// Use this to store application specific shape data.
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// An array of at least 4 points. These are cloned and may be temporary.
  /// </summary>
  public IntPtr /* const b2Vec2* */ points;

  /// <summary>
  /// The point count, must be 4 or more.
  /// </summary>
  public int count;

  /// <summary>
  /// The friction coefficient, usually in the range [0,1].
  /// </summary>
  public float friction;

  /// <summary>
  /// The restitution (elasticity) usually in the range [0,1].
  /// </summary>
  public float restitution;

  /// <summary>
  /// Contact filtering data.
  /// </summary>
  public b2Filter filter;

  /// <summary>
  /// Custom debug draw color.
  /// </summary>
  public uint customColor;

  /// <summary>
  /// Indicates a closed chain formed by connecting the first and last points
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool isLoop;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// Profiling data. Times are in milliseconds.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Profile
{

  public float step;

  public float pairs;

  public float collide;

  public float solve;

  public float buildIslands;

  public float solveConstraints;

  public float prepareTasks;

  public float solverTasks;

  public float prepareConstraints;

  public float integrateVelocities;

  public float warmStart;

  public float solveVelocities;

  public float integratePositions;

  public float relaxVelocities;

  public float applyRestitution;

  public float storeImpulses;

  public float finalizeBodies;

  public float splitIslands;

  public float sleepIslands;

  public float hitEvents;

  public float broadphase;

  public float continuous;
}

  /// <summary>
  /// Counters that give details of the simulation size.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2Counters
{

  public int bodyCount;

  public int shapeCount;

  public int contactCount;

  public int jointCount;

  public int islandCount;

  public int stackUsed;

  public int staticTreeHeight;

  public int treeHeight;

  public int byteCount;

  public int taskCount;

  [MarshalAs(UnmanagedType.ByValArray, SizeConst = 12)]
  public int[] colorCounts;
}

  /// <summary>
  /// Distance joint definition
  /// 
  /// This requires defining an anchor point on both
  /// bodies and the non-zero distance of the distance joint. The definition uses
  /// local anchor points so that the initial configuration can violate the
  /// constraint slightly. This helps when saving and loading a game.
  /// @ingroup distance_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2DistanceJointDef
{

  /// <summary>
  /// The first attached body
  /// </summary>
  public b2BodyId bodyIdA;

  /// <summary>
  /// The second attached body
  /// </summary>
  public b2BodyId bodyIdB;

  /// <summary>
  /// The local anchor point relative to bodyA's origin
  /// </summary>
  public Vector2 localAnchorA;

  /// <summary>
  /// The local anchor point relative to bodyB's origin
  /// </summary>
  public Vector2 localAnchorB;

  /// <summary>
  /// The rest length of this joint. Clamped to a stable minimum value.
  /// </summary>
  public float length;

  /// <summary>
  /// Enable the distance constraint to behave like a spring. If false
  /// then the distance joint will be rigid, overriding the limit and motor.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSpring;

  /// <summary>
  /// The spring linear stiffness Hertz, cycles per second
  /// </summary>
  public float hertz;

  /// <summary>
  /// The spring linear damping ratio, non-dimensional
  /// </summary>
  public float dampingRatio;

  /// <summary>
  /// Enable/disable the joint limit
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableLimit;

  /// <summary>
  /// Minimum length. Clamped to a stable minimum value.
  /// </summary>
  public float minLength;

  /// <summary>
  /// Maximum length. Must be greater than or equal to the minimum length.
  /// </summary>
  public float maxLength;

  /// <summary>
  /// Enable/disable the joint motor
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableMotor;

  /// <summary>
  /// The maximum motor force, usually in newtons
  /// </summary>
  public float maxMotorForce;

  /// <summary>
  /// The desired motor speed, usually in meters per second
  /// </summary>
  public float motorSpeed;

  /// <summary>
  /// Set this flag to true if the attached bodies should collide
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool collideConnected;

  /// <summary>
  /// User data pointer
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// A motor joint is used to control the relative motion between two bodies
  /// 
  /// A typical usage is to control the movement of a dynamic body with respect to the ground.
  /// @ingroup motor_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2MotorJointDef
{

  /// <summary>
  /// The first attached body
  /// </summary>
  public b2BodyId bodyIdA;

  /// <summary>
  /// The second attached body
  /// </summary>
  public b2BodyId bodyIdB;

  /// <summary>
  /// Position of bodyB minus the position of bodyA, in bodyA's frame
  /// </summary>
  public Vector2 linearOffset;

  /// <summary>
  /// The bodyB angle minus bodyA angle in radians
  /// </summary>
  public float angularOffset;

  /// <summary>
  /// The maximum motor force in newtons
  /// </summary>
  public float maxForce;

  /// <summary>
  /// The maximum motor torque in newton-meters
  /// </summary>
  public float maxTorque;

  /// <summary>
  /// Position correction factor in the range [0,1]
  /// </summary>
  public float correctionFactor;

  /// <summary>
  /// Set this flag to true if the attached bodies should collide
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool collideConnected;

  /// <summary>
  /// User data pointer
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// A mouse joint is used to make a point on a body track a specified world point.
  /// 
  /// This a soft constraint and allows the constraint to stretch without
  /// applying huge forces. This also applies rotation constraint heuristic to improve control.
  /// @ingroup mouse_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2MouseJointDef
{

  /// <summary>
  /// The first attached body.
  /// </summary>
  public b2BodyId bodyIdA;

  /// <summary>
  /// The second attached body.
  /// </summary>
  public b2BodyId bodyIdB;

  /// <summary>
  /// The initial target point in world space
  /// </summary>
  public Vector2 target;

  /// <summary>
  /// Stiffness in hertz
  /// </summary>
  public float hertz;

  /// <summary>
  /// Damping ratio, non-dimensional
  /// </summary>
  public float dampingRatio;

  /// <summary>
  /// Maximum force, typically in newtons
  /// </summary>
  public float maxForce;

  /// <summary>
  /// Set this flag to true if the attached bodies should collide.
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool collideConnected;

  /// <summary>
  /// User data pointer
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// A null joint is used to disable collision between two specific bodies.
  /// 
  /// @ingroup null_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2NullJointDef
{

  /// <summary>
  /// The first attached body.
  /// </summary>
  public b2BodyId bodyIdA;

  /// <summary>
  /// The second attached body.
  /// </summary>
  public b2BodyId bodyIdB;

  /// <summary>
  /// User data pointer
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// Prismatic joint definition
  /// 
  /// This requires defining a line of motion using an axis and an anchor point.
  /// The definition uses local anchor points and a local axis so that the initial
  /// configuration can violate the constraint slightly. The joint translation is zero
  /// when the local anchor points coincide in world space.
  /// @ingroup prismatic_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2PrismaticJointDef
{

  /// <summary>
  /// The first attached body
  /// </summary>
  public b2BodyId bodyIdA;

  /// <summary>
  /// The second attached body
  /// </summary>
  public b2BodyId bodyIdB;

  /// <summary>
  /// The local anchor point relative to bodyA's origin
  /// </summary>
  public Vector2 localAnchorA;

  /// <summary>
  /// The local anchor point relative to bodyB's origin
  /// </summary>
  public Vector2 localAnchorB;

  /// <summary>
  /// The local translation unit axis in bodyA
  /// </summary>
  public Vector2 localAxisA;

  /// <summary>
  /// The constrained angle between the bodies: bodyB_angle - bodyA_angle
  /// </summary>
  public float referenceAngle;

  /// <summary>
  /// Enable a linear spring along the prismatic joint axis
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSpring;

  /// <summary>
  /// The spring stiffness Hertz, cycles per second
  /// </summary>
  public float hertz;

  /// <summary>
  /// The spring damping ratio, non-dimensional
  /// </summary>
  public float dampingRatio;

  /// <summary>
  /// Enable/disable the joint limit
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableLimit;

  /// <summary>
  /// The lower translation limit
  /// </summary>
  public float lowerTranslation;

  /// <summary>
  /// The upper translation limit
  /// </summary>
  public float upperTranslation;

  /// <summary>
  /// Enable/disable the joint motor
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableMotor;

  /// <summary>
  /// The maximum motor force, typically in newtons
  /// </summary>
  public float maxMotorForce;

  /// <summary>
  /// The desired motor speed, typically in meters per second
  /// </summary>
  public float motorSpeed;

  /// <summary>
  /// Set this flag to true if the attached bodies should collide
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool collideConnected;

  /// <summary>
  /// User data pointer
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// Revolute joint definition
  /// 
  /// This requires defining an anchor point where the bodies are joined.
  /// The definition uses local anchor points so that the
  /// initial configuration can violate the constraint slightly. You also need to
  /// specify the initial relative angle for joint limits. This helps when saving
  /// and loading a game.
  /// The local anchor points are measured from the body's origin
  /// rather than the center of mass because:
  /// 1. you might not know where the center of mass will be
  /// 2. if you add/remove shapes from a body and recompute the mass, the joints will be broken
  /// @ingroup revolute_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2RevoluteJointDef
{

  /// <summary>
  /// The first attached body
  /// </summary>
  public b2BodyId bodyIdA;

  /// <summary>
  /// The second attached body
  /// </summary>
  public b2BodyId bodyIdB;

  /// <summary>
  /// The local anchor point relative to bodyA's origin
  /// </summary>
  public Vector2 localAnchorA;

  /// <summary>
  /// The local anchor point relative to bodyB's origin
  /// </summary>
  public Vector2 localAnchorB;

  /// <summary>
  /// The bodyB angle minus bodyA angle in the reference state (radians).
  /// This defines the zero angle for the joint limit.
  /// </summary>
  public float referenceAngle;

  /// <summary>
  /// Enable a rotational spring on the revolute hinge axis
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSpring;

  /// <summary>
  /// The spring stiffness Hertz, cycles per second
  /// </summary>
  public float hertz;

  /// <summary>
  /// The spring damping ratio, non-dimensional
  /// </summary>
  public float dampingRatio;

  /// <summary>
  /// A flag to enable joint limits
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableLimit;

  /// <summary>
  /// The lower angle for the joint limit in radians
  /// </summary>
  public float lowerAngle;

  /// <summary>
  /// The upper angle for the joint limit in radians
  /// </summary>
  public float upperAngle;

  /// <summary>
  /// A flag to enable the joint motor
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableMotor;

  /// <summary>
  /// The maximum motor torque, typically in newton-meters
  /// </summary>
  public float maxMotorTorque;

  /// <summary>
  /// The desired motor speed in radians per second
  /// </summary>
  public float motorSpeed;

  /// <summary>
  /// Scale the debug draw
  /// </summary>
  public float drawSize;

  /// <summary>
  /// Set this flag to true if the attached bodies should collide
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool collideConnected;

  /// <summary>
  /// User data pointer
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// Weld joint definition
  /// 
  /// A weld joint connect to bodies together rigidly. This constraint provides springs to mimic
  /// soft-body simulation.
  /// @note The approximate solver in Box2D cannot hold many bodies together rigidly
  /// @ingroup weld_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2WeldJointDef
{

  /// <summary>
  /// The first attached body
  /// </summary>
  public b2BodyId bodyIdA;

  /// <summary>
  /// The second attached body
  /// </summary>
  public b2BodyId bodyIdB;

  /// <summary>
  /// The local anchor point relative to bodyA's origin
  /// </summary>
  public Vector2 localAnchorA;

  /// <summary>
  /// The local anchor point relative to bodyB's origin
  /// </summary>
  public Vector2 localAnchorB;

  /// <summary>
  /// The bodyB angle minus bodyA angle in the reference state (radians)
  /// </summary>
  public float referenceAngle;

  /// <summary>
  /// Linear stiffness expressed as Hertz (cycles per second). Use zero for maximum stiffness.
  /// </summary>
  public float linearHertz;

  /// <summary>
  /// Angular stiffness as Hertz (cycles per second). Use zero for maximum stiffness.
  /// </summary>
  public float angularHertz;

  /// <summary>
  /// Linear damping ratio, non-dimensional. Use 1 for critical damping.
  /// </summary>
  public float linearDampingRatio;

  /// <summary>
  /// Linear damping ratio, non-dimensional. Use 1 for critical damping.
  /// </summary>
  public float angularDampingRatio;

  /// <summary>
  /// Set this flag to true if the attached bodies should collide
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool collideConnected;

  /// <summary>
  /// User data pointer
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// Wheel joint definition
  /// 
  /// This requires defining a line of motion using an axis and an anchor point.
  /// The definition uses local  anchor points and a local axis so that the initial
  /// configuration can violate the constraint slightly. The joint translation is zero
  /// when the local anchor points coincide in world space.
  /// @ingroup wheel_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2WheelJointDef
{

  /// <summary>
  /// The first attached body
  /// </summary>
  public b2BodyId bodyIdA;

  /// <summary>
  /// The second attached body
  /// </summary>
  public b2BodyId bodyIdB;

  /// <summary>
  /// The local anchor point relative to bodyA's origin
  /// </summary>
  public Vector2 localAnchorA;

  /// <summary>
  /// The local anchor point relative to bodyB's origin
  /// </summary>
  public Vector2 localAnchorB;

  /// <summary>
  /// The local translation unit axis in bodyA
  /// </summary>
  public Vector2 localAxisA;

  /// <summary>
  /// Enable a linear spring along the local axis
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSpring;

  /// <summary>
  /// Spring stiffness in Hertz
  /// </summary>
  public float hertz;

  /// <summary>
  /// Spring damping ratio, non-dimensional
  /// </summary>
  public float dampingRatio;

  /// <summary>
  /// Enable/disable the joint linear limit
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableLimit;

  /// <summary>
  /// The lower translation limit
  /// </summary>
  public float lowerTranslation;

  /// <summary>
  /// The upper translation limit
  /// </summary>
  public float upperTranslation;

  /// <summary>
  /// Enable/disable the joint rotational motor
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableMotor;

  /// <summary>
  /// The maximum motor torque, typically in newton-meters
  /// </summary>
  public float maxMotorTorque;

  /// <summary>
  /// The desired motor speed in radians per second
  /// </summary>
  public float motorSpeed;

  /// <summary>
  /// Set this flag to true if the attached bodies should collide
  /// </summary>
  [MarshalAs(UnmanagedType.U1)]
  public bool collideConnected;

  /// <summary>
  /// User data pointer
  /// </summary>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  public int internalValue;
}

  /// <summary>
  /// The explosion definition is used to configure options for explosions. Explosions
  /// consider shape geometry when computing the impulse.
  /// @ingroup world
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ExplosionDef
{

  /// <summary>
  /// Mask bits to filter shapes
  /// </summary>
  public UInt64 maskBits;

  /// <summary>
  /// The center of the explosion in world space
  /// </summary>
  public Vector2 position;

  /// <summary>
  /// The radius of the explosion
  /// </summary>
  public float radius;

  /// <summary>
  /// The falloff distance beyond the radius. Impulse is reduced to zero at this distance.
  /// </summary>
  public float falloff;

  /// <summary>
  /// Impulse per unit length. This applies an impulse according to the shape perimeter that
  /// is facing the explosion. Explosions only apply to circles, capsules, and polygons. This
  /// may be negative for implosions.
  /// </summary>
  public float impulsePerLength;
}

  /// <summary>
  /// A begin touch event is generated when a shape starts to overlap a sensor shape.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2SensorBeginTouchEvent
{

  /// <summary>
  /// The id of the sensor shape
  /// </summary>
  public b2ShapeId sensorShapeId;

  /// <summary>
  /// The id of the dynamic shape that began touching the sensor shape
  /// </summary>
  public b2ShapeId visitorShapeId;
}

  /// <summary>
  /// An end touch event is generated when a shape stops overlapping a sensor shape.
  /// You will get an end event if you do anything that destroys contacts previous to the last
  /// world step.  These include things like setting the transform, destroying a body
  /// or shape, or changing a filter or body type.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2SensorEndTouchEvent
{

  /// <summary>
  /// The id of the sensor shape
  /// @warning this shape may have been destroyed
  /// @see b2Shape_IsValid
  /// </summary>
  public b2ShapeId sensorShapeId;

  /// <summary>
  /// The id of the dynamic shape that stopped touching the sensor shape
  /// @warning this shape may have been destroyed
  /// @see b2Shape_IsValid
  /// </summary>
  public b2ShapeId visitorShapeId;
}

  /// <summary>
  /// Sensor events are buffered in the Box2D world and are available
  /// as begin/end overlap event arrays after the time step is complete.
  /// Note: these may become invalid if bodies and/or shapes are destroyed
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2SensorEvents
{

  /// <summary>
  /// Array of sensor begin touch events
  /// </summary>
  public IntPtr /* b2SensorBeginTouchEvent* */ beginEvents;

  /// <summary>
  /// Array of sensor end touch events
  /// </summary>
  public IntPtr /* b2SensorEndTouchEvent* */ endEvents;

  /// <summary>
  /// The number of begin touch events
  /// </summary>
  public int beginCount;

  /// <summary>
  /// The number of end touch events
  /// </summary>
  public int endCount;
}

  /// <summary>
  /// A begin touch event is generated when two shapes begin touching.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ContactBeginTouchEvent
{

  /// <summary>
  /// Id of the first shape
  /// </summary>
  public b2ShapeId shapeIdA;

  /// <summary>
  /// Id of the second shape
  /// </summary>
  public b2ShapeId shapeIdB;

  /// <summary>
  /// The initial contact manifold
  /// </summary>
  public b2Manifold manifold;
}

  /// <summary>
  /// An end touch event is generated when two shapes stop touching.
  /// You will get an end event if you do anything that destroys contacts previous to the last
  /// world step. These include things like setting the transform, destroying a body
  /// or shape, or changing a filter or body type.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ContactEndTouchEvent
{

  /// <summary>
  /// Id of the first shape
  /// @warning this shape may have been destroyed
  /// @see b2Shape_IsValid
  /// </summary>
  public b2ShapeId shapeIdA;

  /// <summary>
  /// Id of the second shape
  /// @warning this shape may have been destroyed
  /// @see b2Shape_IsValid
  /// </summary>
  public b2ShapeId shapeIdB;
}

  /// <summary>
  /// A hit touch event is generated when two shapes collide with a speed faster than the hit speed threshold.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ContactHitEvent
{

  /// <summary>
  /// Id of the first shape
  /// </summary>
  public b2ShapeId shapeIdA;

  /// <summary>
  /// Id of the second shape
  /// </summary>
  public b2ShapeId shapeIdB;

  /// <summary>
  /// Point where the shapes hit
  /// </summary>
  public Vector2 point;

  /// <summary>
  /// Normal vector pointing from shape A to shape B
  /// </summary>
  public Vector2 normal;

  /// <summary>
  /// The speed the shapes are approaching. Always positive. Typically in meters per second.
  /// </summary>
  public float approachSpeed;
}

  /// <summary>
  /// Contact events are buffered in the Box2D world and are available
  /// as event arrays after the time step is complete.
  /// Note: these may become invalid if bodies and/or shapes are destroyed
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ContactEvents
{

  /// <summary>
  /// Array of begin touch events
  /// </summary>
  public IntPtr /* b2ContactBeginTouchEvent* */ beginEvents;

  /// <summary>
  /// Array of end touch events
  /// </summary>
  public IntPtr /* b2ContactEndTouchEvent* */ endEvents;

  /// <summary>
  /// Array of hit events
  /// </summary>
  public IntPtr /* b2ContactHitEvent* */ hitEvents;

  /// <summary>
  /// Number of begin touch events
  /// </summary>
  public int beginCount;

  /// <summary>
  /// Number of end touch events
  /// </summary>
  public int endCount;

  /// <summary>
  /// Number of hit events
  /// </summary>
  public int hitCount;
}

  /// <summary>
  /// Body move events triggered when a body moves.
  /// Triggered when a body moves due to simulation. Not reported for bodies moved by the user.
  /// This also has a flag to indicate that the body went to sleep so the application can also
  /// sleep that actor/entity/object associated with the body.
  /// On the other hand if the flag does not indicate the body went to sleep then the application
  /// can treat the actor/entity/object associated with the body as awake.
  /// This is an efficient way for an application to update game object transforms rather than
  /// calling functions such as b2Body_GetTransform() because this data is delivered as a contiguous array
  /// and it is only populated with bodies that have moved.
  /// @note If sleeping is disabled all dynamic and kinematic bodies will trigger move events.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2BodyMoveEvent
{

  public b2Transform transform;

  public b2BodyId bodyId;

  public IntPtr /* void* */ userData;

  [MarshalAs(UnmanagedType.U1)]
  public bool fellAsleep;
}

  /// <summary>
  /// Body events are buffered in the Box2D world and are available
  /// as event arrays after the time step is complete.
  /// Note: this data becomes invalid if bodies are destroyed
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2BodyEvents
{

  /// <summary>
  /// Array of move events
  /// </summary>
  public IntPtr /* b2BodyMoveEvent* */ moveEvents;

  /// <summary>
  /// Number of move events
  /// </summary>
  public int moveCount;
}

  /// <summary>
  /// The contact data for two shapes. By convention the manifold normal points
  /// from shape A to shape B.
  /// @see b2Shape_GetContactData() and b2Body_GetContactData()
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public  partial struct b2ContactData
{

  public b2ShapeId shapeIdA;

  public b2ShapeId shapeIdB;

  public b2Manifold manifold;
}

/// <summary>
/// The (more or less) full Box2D v3.x API as PInvoke functions. (functions marked with C macro 'B2_API' in original sources)
/// </summary>
public static partial class B2Api
    {
#if DEBUG
        private const string Box2DLibrary = "box2dd.dll";
#else
        private const string Box2DLibrary = "box2d.dll";
#endif

public const int B2_HASH_INIT = 5381;

  /// <summary>
  /// The maximum number of vertices on a convex polygon. Changing this affects performance even if you
  /// don't use more vertices.
  /// </summary>
public const int b2_maxPolygonVertices = 8;

  /// <summary>
  /// https://en.wikipedia.org/wiki/Pi
  /// </summary>
public const float b2_pi = 3.14159265359f;

public const int B2_DEFAULT_CATEGORY_BITS = 0;

  /// <summary>
  /// This allows the user to override the allocation functions. These should be
  /// set during application startup.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2SetAllocator(IntPtr /* b2AllocFcn */ allocFcn, IntPtr /* b2FreeFcn */ freeFcn);

  /// <summary>
  /// @return the total bytes allocated by Box2D
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2GetByteCount();

  /// <summary>
  /// Override the default assert callback
  /// </summary>
  /// <param name="assertFcn">a non-null assert callback</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2SetAssertFcn(IntPtr /* b2AssertFcn */ assertFcn);

  /// <summary>
  /// Get the current version of Box2D
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Version b2GetVersion();

[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2SleepMilliseconds(int milliseconds);

[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Yield();

[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern uint b2Hash(uint hash, IntPtr /* uint8_t* */ data, int count);

  /// <summary>
  /// Create a world for rigid body simulation. A world contains bodies, shapes, and constraints. You make create
  /// up to 128 worlds. Each world is completely independent and may be simulated in parallel.
  /// @return the world id.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2CreateWorld(in b2WorldDef def);

  /// <summary>
  /// Destroy a world
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyWorld(b2WorldId worldId);

  /// <summary>
  /// World id validation. Provides validation for up to 64K allocations.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2World_IsValid(b2WorldId id);

  /// <summary>
  /// Simulate a world for one time step. This performs collision detection, integration, and constraint solution.
  /// </summary>
  /// <param name="worldId">The world to simulate</param>
  /// <param name="timeStep">The amount of time to simulate, this should be a fixed number. Typically 1/60.</param>
  /// <param name="subStepCount">The number of sub-steps, increasing the sub-step count can increase accuracy. Typically 4.</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_Step(b2WorldId worldId, float timeStep, int subStepCount);

  /// <summary>
  /// Get the body events for the current time step. The event data is transient. Do not store a reference to this data.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyEvents b2World_GetBodyEvents(b2WorldId worldId);

  /// <summary>
  /// Get sensor events for the current time step. The event data is transient. Do not store a reference to this data.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2SensorEvents b2World_GetSensorEvents(b2WorldId worldId);

  /// <summary>
  /// Get contact events for this current time step. The event data is transient. Do not store a reference to this data.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ContactEvents b2World_GetContactEvents(b2WorldId worldId);

  /// <summary>
  /// Overlap test for all shapes that *potentially* overlap the provided AABB
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_OverlapAABB(b2WorldId worldId, b2AABB aabb, b2QueryFilter filter, IntPtr /* b2OverlapResultFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Overlap test for for all shapes that overlap the provided point.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_OverlapPoint(b2WorldId worldId, Vector2 point, b2Transform transform, b2QueryFilter filter, IntPtr /* b2OverlapResultFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Overlap test for for all shapes that overlap the provided circle. A zero radius may be used for a point query.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_OverlapCircle(b2WorldId worldId, in b2Circle circle, b2Transform transform, b2QueryFilter filter, IntPtr /* b2OverlapResultFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Overlap test for all shapes that overlap the provided capsule
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_OverlapCapsule(b2WorldId worldId, in b2Capsule capsule, b2Transform transform, b2QueryFilter filter, IntPtr /* b2OverlapResultFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Overlap test for all shapes that overlap the provided polygon
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_OverlapPolygon(b2WorldId worldId, in b2Polygon polygon, b2Transform transform, b2QueryFilter filter, IntPtr /* b2OverlapResultFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Cast a ray into the world to collect shapes in the path of the ray.
  /// Your callback function controls whether you get the closest point, any point, or n-points.
  /// The ray-cast ignores shapes that contain the starting point.
  /// @note The callback function may receive shapes in any order
  /// @return traversal performance counters
  /// </summary>
  /// <param name="worldId">The world to cast the ray against</param>
  /// <param name="origin">The start point of the ray</param>
  /// <param name="translation">The translation of the ray from the start point to the end point</param>
  /// <param name="filter">Contains bit flags to filter unwanted shapes from the results</param>
  /// <param name="fcn">A user implemented callback function</param>
  /// <param name="context">A user context that is passed along to the callback function</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_CastRay(b2WorldId worldId, Vector2 origin, Vector2 translation, b2QueryFilter filter, IntPtr /* b2CastResultFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Cast a ray into the world to collect the closest hit. This is a convenience function.
  /// This is less general than b2World_CastRay() and does not allow for custom filtering.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2RayResult b2World_CastRayClosest(b2WorldId worldId, Vector2 origin, Vector2 translation, b2QueryFilter filter);

  /// <summary>
  /// Cast a circle through the world. Similar to a cast ray except that a circle is cast instead of a point.
  /// @see b2World_CastRay
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_CastCircle(b2WorldId worldId, in b2Circle circle, b2Transform originTransform, Vector2 translation, b2QueryFilter filter, IntPtr /* b2CastResultFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Cast a capsule through the world. Similar to a cast ray except that a capsule is cast instead of a point.
  /// @see b2World_CastRay
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_CastCapsule(b2WorldId worldId, in b2Capsule capsule, b2Transform originTransform, Vector2 translation, b2QueryFilter filter, IntPtr /* b2CastResultFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Cast a polygon through the world. Similar to a cast ray except that a polygon is cast instead of a point.
  /// @see b2World_CastRay
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_CastPolygon(b2WorldId worldId, in b2Polygon polygon, b2Transform originTransform, Vector2 translation, b2QueryFilter filter, IntPtr /* b2CastResultFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Enable/disable sleep. If your application does not need sleeping, you can gain some performance
  /// by disabling sleep completely at the world level.
  /// @see b2WorldDef
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_EnableSleeping(b2WorldId worldId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Is body sleeping enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2World_IsSleepingEnabled(b2WorldId worldId);

  /// <summary>
  /// Enable/disable continuous collision between dynamic and static bodies. Generally you should keep continuous
  /// collision enabled to prevent fast moving objects from going through static objects. The performance gain from
  /// disabling continuous collision is minor.
  /// @see b2WorldDef
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_EnableContinuous(b2WorldId worldId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Is continuous collision enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2World_IsContinuousEnabled(b2WorldId worldId);

  /// <summary>
  /// Adjust the restitution threshold. It is recommended not to make this value very small
  /// because it will prevent bodies from sleeping. Typically in meters per second.
  /// @see b2WorldDef
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetRestitutionThreshold(b2WorldId worldId, float value);

  /// <summary>
  /// Get the the restitution speed threshold. Typically in meters per second.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2World_GetRestitutionThreshold(b2WorldId worldId);

  /// <summary>
  /// Adjust the hit event threshold. This controls the collision velocity needed to generate a b2ContactHitEvent.
  /// Typically in meters per second.
  /// @see b2WorldDef::hitEventThreshold
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetHitEventThreshold(b2WorldId worldId, float value);

  /// <summary>
  /// Get the the hit event speed threshold. Typically in meters per second.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2World_GetHitEventThreshold(b2WorldId worldId);

  /// <summary>
  /// Register the custom filter callback. This is optional.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetCustomFilterCallback(b2WorldId worldId, IntPtr /* b2CustomFilterFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Register the pre-solve callback. This is optional.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetPreSolveCallback(b2WorldId worldId, IntPtr /* b2PreSolveFcn */ fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Set the gravity vector for the entire world. Box2D has no concept of an up direction and this
  /// is left as a decision for the application. Typically in m/s^2.
  /// @see b2WorldDef
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetGravity(b2WorldId worldId, Vector2 gravity);

  /// <summary>
  /// Get the gravity vector
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2World_GetGravity(b2WorldId worldId);

  /// <summary>
  /// Apply a radial explosion
  /// </summary>
  /// <param name="worldId">The world id</param>
  /// <param name="explosionDef">The explosion definition</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_Explode(b2WorldId worldId, in b2ExplosionDef explosionDef);

  /// <summary>
  /// Adjust contact tuning parameters
  /// @note Advanced feature
  /// </summary>
  /// <param name="worldId">The world id</param>
  /// <param name="hertz">The contact stiffness (cycles per second)</param>
  /// <param name="dampingRatio">The contact bounciness with 1 being critical damping (non-dimensional)</param>
  /// <param name="pushVelocity">The maximum contact constraint push out velocity (meters per second)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetContactTuning(b2WorldId worldId, float hertz, float dampingRatio, float pushVelocity);

  /// <summary>
  /// Adjust joint tuning parameters
  /// @note Advanced feature
  /// </summary>
  /// <param name="worldId">The world id</param>
  /// <param name="hertz">The contact stiffness (cycles per second)</param>
  /// <param name="dampingRatio">The contact bounciness with 1 being critical damping (non-dimensional)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetJointTuning(b2WorldId worldId, float hertz, float dampingRatio);

  /// <summary>
  /// Set the maximum linear velocity. Typically in m/s.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetMaximumLinearVelocity(b2WorldId worldId, float maximumLinearVelocity);

  /// <summary>
  /// Get the maximum linear velocity. Typically in m/s.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2World_GetMaximumLinearVelocity(b2WorldId worldId);

  /// <summary>
  /// Enable/disable constraint warm starting. Advanced feature for testing. Disabling
  /// sleeping greatly reduces stability and provides no performance gain.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_EnableWarmStarting(b2WorldId worldId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Is constraint warm starting enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2World_IsWarmStartingEnabled(b2WorldId worldId);

  /// <summary>
  /// Get the current world performance profile
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Profile b2World_GetProfile(b2WorldId worldId);

  /// <summary>
  /// Get world counters and sizes
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Counters b2World_GetCounters(b2WorldId worldId);

  /// <summary>
  /// Set the user data pointer.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetUserData(b2WorldId worldId, IntPtr /* void* */ userData);

  /// <summary>
  /// Get the user data pointer.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr /* void* */ b2World_GetUserData(b2WorldId worldId);

  /// <summary>
  /// Dump memory stats to box2d_memory.txt
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_DumpMemoryStats(b2WorldId worldId);

  /// <summary>
  /// todo testing
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_RebuildStaticTree(b2WorldId worldId);

  /// <summary>
  /// Create a rigid body given a definition. No reference to the definition is retained. So you can create the definition
  /// on the stack and pass it as a pointer.
  /// @code{.c}
  /// b2BodyDef bodyDef = b2DefaultBodyDef();
  /// b2BodyId myBodyId = b2CreateBody(myWorldId, &bodyDef);
  /// @endcode
  /// @warning This function is locked during callbacks.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyId b2CreateBody(b2WorldId worldId, in b2BodyDef def);

  /// <summary>
  /// Destroy a rigid body given an id. This destroys all shapes and joints attached to the body.
  /// Do not keep references to the associated shapes and joints.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyBody(b2BodyId bodyId);

  /// <summary>
  /// Body identifier validation. Can be used to detect orphaned ids. Provides validation for up to 64K allocations.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsValid(b2BodyId id);

  /// <summary>
  /// Get the body type: static, kinematic, or dynamic
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyType b2Body_GetType(b2BodyId bodyId);

  /// <summary>
  /// Change the body type. This is an expensive operation. This automatically updates the mass
  /// properties regardless of the automatic mass setting.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetType(b2BodyId bodyId, b2BodyType type);

  /// <summary>
  /// Set the user data for a body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetUserData(b2BodyId bodyId, IntPtr /* void* */ userData);

  /// <summary>
  /// Get the user data stored in a body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr /* void* */ b2Body_GetUserData(b2BodyId bodyId);

  /// <summary>
  /// Get the world position of a body. This is the location of the body origin.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetPosition(b2BodyId bodyId);

  /// <summary>
  /// Get the world rotation of a body as a cosine/sine pair (complex number)
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Rot b2Body_GetRotation(b2BodyId bodyId);

  /// <summary>
  /// Get the world transform of a body.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Transform b2Body_GetTransform(b2BodyId bodyId);

  /// <summary>
  /// Set the world transform of a body. This acts as a teleport and is fairly expensive.
  /// @note Generally you should create a body with then intended transform.
  /// @see b2BodyDef::position and b2BodyDef::angle
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetTransform(b2BodyId bodyId, Vector2 position, b2Rot rotation);

  /// <summary>
  /// Get a local point on a body given a world point
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetLocalPoint(b2BodyId bodyId, Vector2 worldPoint);

  /// <summary>
  /// Get a world point on a body given a local point
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetWorldPoint(b2BodyId bodyId, Vector2 localPoint);

  /// <summary>
  /// Get a local vector on a body given a world vector
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetLocalVector(b2BodyId bodyId, Vector2 worldVector);

  /// <summary>
  /// Get a world vector on a body given a local vector
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetWorldVector(b2BodyId bodyId, Vector2 localVector);

  /// <summary>
  /// Get the linear velocity of a body's center of mass. Typically in meters per second.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetLinearVelocity(b2BodyId bodyId);

  /// <summary>
  /// Get the angular velocity of a body in radians per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetAngularVelocity(b2BodyId bodyId);

  /// <summary>
  /// Set the linear velocity of a body. Typically in meters per second.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetLinearVelocity(b2BodyId bodyId, Vector2 linearVelocity);

  /// <summary>
  /// Set the angular velocity of a body in radians per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetAngularVelocity(b2BodyId bodyId, float angularVelocity);

  /// <summary>
  /// Apply a force at a world point. If the force is not applied at the center of mass,
  /// it will generate a torque and affect the angular velocity. This optionally wakes up the body.
  /// The force is ignored if the body is not awake.
  /// </summary>
  /// <param name="bodyId">The body id</param>
  /// <param name="force">The world force vector, typically in newtons (N)</param>
  /// <param name="point">The world position of the point of application</param>
  /// <param name="wake">Option to wake up the body</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyForce(b2BodyId bodyId, Vector2 force, Vector2 point, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply a force to the center of mass. This optionally wakes up the body.
  /// The force is ignored if the body is not awake.
  /// </summary>
  /// <param name="bodyId">The body id</param>
  /// <param name="force">the world force vector, usually in newtons (N).</param>
  /// <param name="wake">also wake up the body</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyForceToCenter(b2BodyId bodyId, Vector2 force, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply a torque. This affects the angular velocity without affecting the linear velocity.
  /// This optionally wakes the body. The torque is ignored if the body is not awake.
  /// </summary>
  /// <param name="bodyId">The body id</param>
  /// <param name="torque">about the z-axis (out of the screen), typically in N*m.</param>
  /// <param name="wake">also wake up the body</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyTorque(b2BodyId bodyId, float torque, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply an impulse at a point. This immediately modifies the velocity.
  /// It also modifies the angular velocity if the point of application
  /// is not at the center of mass. This optionally wakes the body.
  /// The impulse is ignored if the body is not awake.
  /// @warning This should be used for one-shot impulses. If you need a steady force,
  /// use a force instead, which will work better with the sub-stepping solver.
  /// </summary>
  /// <param name="bodyId">The body id</param>
  /// <param name="impulse">the world impulse vector, typically in N*s or kg*m/s.</param>
  /// <param name="point">the world position of the point of application.</param>
  /// <param name="wake">also wake up the body</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyLinearImpulse(b2BodyId bodyId, Vector2 impulse, Vector2 point, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply an impulse to the center of mass. This immediately modifies the velocity.
  /// The impulse is ignored if the body is not awake. This optionally wakes the body.
  /// @warning This should be used for one-shot impulses. If you need a steady force,
  /// use a force instead, which will work better with the sub-stepping solver.
  /// </summary>
  /// <param name="bodyId">The body id</param>
  /// <param name="impulse">the world impulse vector, typically in N*s or kg*m/s.</param>
  /// <param name="wake">also wake up the body</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyLinearImpulseToCenter(b2BodyId bodyId, Vector2 impulse, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply an angular impulse. The impulse is ignored if the body is not awake.
  /// This optionally wakes the body.
  /// @warning This should be used for one-shot impulses. If you need a steady force,
  /// use a force instead, which will work better with the sub-stepping solver.
  /// </summary>
  /// <param name="bodyId">The body id</param>
  /// <param name="impulse">the angular impulse, typically in units of kg*m*m/s</param>
  /// <param name="wake">also wake up the body</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyAngularImpulse(b2BodyId bodyId, float impulse, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Get the mass of the body, typically in kilograms
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetMass(b2BodyId bodyId);

  /// <summary>
  /// Get the rotational inertia of the body, typically in kg*m^2
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetRotationalInertia(b2BodyId bodyId);

  /// <summary>
  /// Get the center of mass position of the body in local space
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetLocalCenterOfMass(b2BodyId bodyId);

  /// <summary>
  /// Get the center of mass position of the body in world space
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetWorldCenterOfMass(b2BodyId bodyId);

  /// <summary>
  /// Override the body's mass properties. Normally this is computed automatically using the
  /// shape geometry and density. This information is lost if a shape is added or removed or if the
  /// body type changes.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetMassData(b2BodyId bodyId, b2MassData massData);

  /// <summary>
  /// Get the mass data for a body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MassData b2Body_GetMassData(b2BodyId bodyId);

  /// <summary>
  /// This update the mass properties to the sum of the mass properties of the shapes.
  /// This normally does not need to be called unless you called SetMassData to override
  /// the mass and you later want to reset the mass.
  /// You may also use this when automatic mass computation has been disabled.
  /// You should call this regardless of body type.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyMassFromShapes(b2BodyId bodyId);

  /// <summary>
  /// Adjust the linear damping. Normally this is set in b2BodyDef before creation.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetLinearDamping(b2BodyId bodyId, float linearDamping);

  /// <summary>
  /// Get the current linear damping.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetLinearDamping(b2BodyId bodyId);

  /// <summary>
  /// Adjust the angular damping. Normally this is set in b2BodyDef before creation.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetAngularDamping(b2BodyId bodyId, float angularDamping);

  /// <summary>
  /// Get the current angular damping.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetAngularDamping(b2BodyId bodyId);

  /// <summary>
  /// Adjust the gravity scale. Normally this is set in b2BodyDef before creation.
  /// @see b2BodyDef::gravityScale
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetGravityScale(b2BodyId bodyId, float gravityScale);

  /// <summary>
  /// Get the current gravity scale
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetGravityScale(b2BodyId bodyId);

  /// <summary>
  /// @return true if this body is awake
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsAwake(b2BodyId bodyId);

  /// <summary>
  /// Wake a body from sleep. This wakes the entire island the body is touching.
  /// @warning Putting a body to sleep will put the entire island of bodies touching this body to sleep,
  /// which can be expensive and possibly unintuitive.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetAwake(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool awake);

  /// <summary>
  /// Enable or disable sleeping for this body. If sleeping is disabled the body will wake.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_EnableSleep(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool enableSleep);

  /// <summary>
  /// Returns true if sleeping is enabled for this body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsSleepEnabled(b2BodyId bodyId);

  /// <summary>
  /// Set the sleep threshold, typically in meters per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetSleepThreshold(b2BodyId bodyId, float sleepThreshold);

  /// <summary>
  /// Get the sleep threshold, typically in meters per second.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetSleepThreshold(b2BodyId bodyId);

  /// <summary>
  /// Returns true if this body is enabled
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsEnabled(b2BodyId bodyId);

  /// <summary>
  /// Disable a body by removing it completely from the simulation. This is expensive.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_Disable(b2BodyId bodyId);

  /// <summary>
  /// Enable a body by adding it to the simulation. This is expensive.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_Enable(b2BodyId bodyId);

  /// <summary>
  /// Set this body to have fixed rotation. This causes the mass to be reset in all cases.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetFixedRotation(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Does this body have fixed rotation?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsFixedRotation(b2BodyId bodyId);

  /// <summary>
  /// Set this body to be a bullet. A bullet does continuous collision detection
  /// against dynamic bodies (but not other bullets).
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetBullet(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Is this body a bullet?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsBullet(b2BodyId bodyId);

  /// <summary>
  /// Enable/disable hit events on all shapes
  /// @see b2ShapeDef::enableHitEvents
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_EnableHitEvents(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool enableHitEvents);

  /// <summary>
  /// Get the world that owns this body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2Body_GetWorld(b2BodyId bodyId);

  /// <summary>
  /// Get the number of shapes on this body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetShapeCount(b2BodyId bodyId);

  /// <summary>
  /// Get the shape ids for all shapes on this body, up to the provided capacity.
  /// @returns the number of shape ids stored in the user array
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetShapes(b2BodyId bodyId, ref b2ShapeId shapeArray, int capacity);

  /// <summary>
  /// Get the number of joints on this body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetJointCount(b2BodyId bodyId);

  /// <summary>
  /// Get the joint ids for all joints on this body, up to the provided capacity
  /// @returns the number of joint ids stored in the user array
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetJoints(b2BodyId bodyId, ref b2JointId jointArray, int capacity);

  /// <summary>
  /// Get the maximum capacity required for retrieving all the touching contacts on a body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetContactCapacity(b2BodyId bodyId);

  /// <summary>
  /// Get the touching contact data for a body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetContactData(b2BodyId bodyId, ref b2ContactData contactData, int capacity);

  /// <summary>
  /// Get the current world AABB that contains all the attached shapes. Note that this may not encompass the body origin.
  /// If there are no shapes attached then the returned AABB is empty and centered on the body origin.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2Body_ComputeAABB(b2BodyId bodyId);

  /// <summary>
  /// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.
  /// Contacts are not created until the next time step.
  /// @return the shape id for accessing the shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeId b2CreateCircleShape(b2BodyId bodyId, in b2ShapeDef def, in b2Circle circle);

  /// <summary>
  /// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.
  /// Contacts are not created until the next time step.
  /// @return the shape id for accessing the shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeId b2CreateSegmentShape(b2BodyId bodyId, in b2ShapeDef def, in b2Segment segment);

  /// <summary>
  /// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.
  /// Contacts are not created until the next time step.
  /// @return the shape id for accessing the shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeId b2CreateCapsuleShape(b2BodyId bodyId, in b2ShapeDef def, in b2Capsule capsule);

  /// <summary>
  /// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.
  /// Contacts are not created until the next time step.
  /// @return the shape id for accessing the shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeId b2CreatePolygonShape(b2BodyId bodyId, in b2ShapeDef def, in b2Polygon polygon);

  /// <summary>
  /// Destroy a shape. You may defer the body mass update which can improve performance if several shapes on a
  /// body are destroyed at once.
  /// @see b2Body_ApplyMassFromShapes
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyShape(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool updateBodyMass);

  /// <summary>
  /// Shape identifier validation. Provides validation for up to 64K allocations.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_IsValid(b2ShapeId id);

  /// <summary>
  /// Get the type of a shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeType b2Shape_GetType(b2ShapeId shapeId);

  /// <summary>
  /// Get the id of the body that a shape is attached to
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyId b2Shape_GetBody(b2ShapeId shapeId);

  /// <summary>
  /// Get the world that owns this shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2Shape_GetWorld(b2ShapeId shapeId);

  /// <summary>
  /// Returns true If the shape is a sensor
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_IsSensor(b2ShapeId shapeId);

  /// <summary>
  /// Set the user data for a shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetUserData(b2ShapeId shapeId, IntPtr /* void* */ userData);

  /// <summary>
  /// Get the user data for a shape. This is useful when you get a shape id
  /// from an event or query.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr /* void* */ b2Shape_GetUserData(b2ShapeId shapeId);

  /// <summary>
  /// Set the mass density of a shape, typically in kg/m^2.
  /// This will optionally update the mass properties on the parent body.
  /// @see b2ShapeDef::density, b2Body_ApplyMassFromShapes
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetDensity(b2ShapeId shapeId, float density, [MarshalAs(UnmanagedType.U1)] bool updateBodyMass);

  /// <summary>
  /// Get the density of a shape, typically in kg/m^2
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Shape_GetDensity(b2ShapeId shapeId);

  /// <summary>
  /// Set the friction on a shape
  /// @see b2ShapeDef::friction
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetFriction(b2ShapeId shapeId, float friction);

  /// <summary>
  /// Get the friction of a shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Shape_GetFriction(b2ShapeId shapeId);

  /// <summary>
  /// Set the shape restitution (bounciness)
  /// @see b2ShapeDef::restitution
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetRestitution(b2ShapeId shapeId, float restitution);

  /// <summary>
  /// Get the shape restitution
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Shape_GetRestitution(b2ShapeId shapeId);

  /// <summary>
  /// Get the shape filter
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Filter b2Shape_GetFilter(b2ShapeId shapeId);

  /// <summary>
  /// Set the current filter. This is almost as expensive as recreating the shape.
  /// @see b2ShapeDef::filter
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetFilter(b2ShapeId shapeId, b2Filter filter);

  /// <summary>
  /// Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
  /// @see b2ShapeDef::isSensor
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_EnableSensorEvents(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Returns true if sensor events are enabled
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_AreSensorEventsEnabled(b2ShapeId shapeId);

  /// <summary>
  /// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
  /// @see b2ShapeDef::enableContactEvents
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_EnableContactEvents(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Returns true if contact events are enabled
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_AreContactEventsEnabled(b2ShapeId shapeId);

  /// <summary>
  /// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive
  /// and must be carefully handled due to multithreading. Ignored for sensors.
  /// @see b2PreSolveFcn
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_EnablePreSolveEvents(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Returns true if pre-solve events are enabled
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_ArePreSolveEventsEnabled(b2ShapeId shapeId);

  /// <summary>
  /// Enable contact hit events for this shape. Ignored for sensors.
  /// @see b2WorldDef.hitEventThreshold
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_EnableHitEvents(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Returns true if hit events are enabled
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_AreHitEventsEnabled(b2ShapeId shapeId);

  /// <summary>
  /// Test a point for overlap with a shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_TestPoint(b2ShapeId shapeId, Vector2 point);

  /// <summary>
  /// Ray cast a shape directly
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2Shape_RayCast(b2ShapeId shapeId, in b2RayCastInput input);

  /// <summary>
  /// Get a copy of the shape's circle. Asserts the type is correct.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Circle b2Shape_GetCircle(b2ShapeId shapeId);

  /// <summary>
  /// Get a copy of the shape's line segment. Asserts the type is correct.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Segment b2Shape_GetSegment(b2ShapeId shapeId);

  /// <summary>
  /// Get a copy of the shape's chain segment. These come from chain shapes.
  /// Asserts the type is correct.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ChainSegment b2Shape_GetChainSegment(b2ShapeId shapeId);

  /// <summary>
  /// Get a copy of the shape's capsule. Asserts the type is correct.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Capsule b2Shape_GetCapsule(b2ShapeId shapeId);

  /// <summary>
  /// Get a copy of the shape's convex polygon. Asserts the type is correct.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2Shape_GetPolygon(b2ShapeId shapeId);

  /// <summary>
  /// Allows you to change a shape to be a circle or update the current circle.
  /// This does not modify the mass properties.
  /// @see b2Body_ApplyMassFromShapes
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetCircle(b2ShapeId shapeId, in b2Circle circle);

  /// <summary>
  /// Allows you to change a shape to be a capsule or update the current capsule.
  /// This does not modify the mass properties.
  /// @see b2Body_ApplyMassFromShapes
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetCapsule(b2ShapeId shapeId, in b2Capsule capsule);

  /// <summary>
  /// Allows you to change a shape to be a segment or update the current segment.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetSegment(b2ShapeId shapeId, in b2Segment segment);

  /// <summary>
  /// Allows you to change a shape to be a polygon or update the current polygon.
  /// This does not modify the mass properties.
  /// @see b2Body_ApplyMassFromShapes
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetPolygon(b2ShapeId shapeId, in b2Polygon polygon);

  /// <summary>
  /// Get the parent chain id if the shape type is a chain segment, otherwise
  /// returns b2_nullChainId.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ChainId b2Shape_GetParentChain(b2ShapeId shapeId);

  /// <summary>
  /// Get the maximum capacity required for retrieving all the touching contacts on a shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Shape_GetContactCapacity(b2ShapeId shapeId);

  /// <summary>
  /// Get the touching contact data for a shape. The provided shapeId will be either shapeIdA or shapeIdB on the contact data.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Shape_GetContactData(b2ShapeId shapeId, ref b2ContactData contactData, int capacity);

  /// <summary>
  /// Get the current world AABB
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2Shape_GetAABB(b2ShapeId shapeId);

  /// <summary>
  /// Get the closest point on a shape to a target point. Target and result are in world space.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Shape_GetClosestPoint(b2ShapeId shapeId, Vector2 target);

  /// <summary>
  /// Chain Shape
  /// Create a chain shape
  /// @see b2ChainDef for details
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ChainId b2CreateChain(b2BodyId bodyId, in b2ChainDef def);

  /// <summary>
  /// Destroy a chain shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyChain(b2ChainId chainId);

  /// <summary>
  /// Get the world that owns this chain shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2Chain_GetWorld(b2ChainId chainId);

  /// <summary>
  /// Get the number of segments on this chain
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Chain_GetSegmentCount(b2ChainId chainId);

  /// <summary>
  /// Fill a user array with chain segment shape ids up to the specified capacity. Returns
  /// the actual number of segments returned.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Chain_GetSegments(b2ChainId chainId, ref b2ShapeId segmentArray, int capacity);

  /// <summary>
  /// Set the chain friction
  /// @see b2ChainDef::friction
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Chain_SetFriction(b2ChainId chainId, float friction);

  /// <summary>
  /// Get the chain friction
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Chain_GetFriction(b2ChainId chainId);

  /// <summary>
  /// Set the chain restitution (bounciness)
  /// @see b2ChainDef::restitution
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Chain_SetRestitution(b2ChainId chainId, float restitution);

  /// <summary>
  /// Get the chain restitution
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Chain_GetRestitution(b2ChainId chainId);

  /// <summary>
  /// Chain identifier validation. Provides validation for up to 64K allocations.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Chain_IsValid(b2ChainId id);

  /// <summary>
  /// Destroy a joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyJoint(b2JointId jointId);

  /// <summary>
  /// Joint identifier validation. Provides validation for up to 64K allocations.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Joint_IsValid(b2JointId id);

  /// <summary>
  /// Get the joint type
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointType b2Joint_GetType(b2JointId jointId);

  /// <summary>
  /// Get body A id on a joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyId b2Joint_GetBodyA(b2JointId jointId);

  /// <summary>
  /// Get body B id on a joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyId b2Joint_GetBodyB(b2JointId jointId);

  /// <summary>
  /// Get the world that owns this joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2Joint_GetWorld(b2JointId jointId);

  /// <summary>
  /// Get the local anchor on bodyA
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Joint_GetLocalAnchorA(b2JointId jointId);

  /// <summary>
  /// Get the local anchor on bodyB
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Joint_GetLocalAnchorB(b2JointId jointId);

  /// <summary>
  /// Toggle collision between connected bodies
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_SetCollideConnected(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool shouldCollide);

  /// <summary>
  /// Is collision allowed between connected bodies?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Joint_GetCollideConnected(b2JointId jointId);

  /// <summary>
  /// Set the user data on a joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_SetUserData(b2JointId jointId, IntPtr /* void* */ userData);

  /// <summary>
  /// Get the user data on a joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr /* void* */ b2Joint_GetUserData(b2JointId jointId);

  /// <summary>
  /// Wake the bodies connect to this joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_WakeBodies(b2JointId jointId);

  /// <summary>
  /// Get the current constraint force for this joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Joint_GetConstraintForce(b2JointId jointId);

  /// <summary>
  /// Get the current constraint torque for this joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Joint_GetConstraintTorque(b2JointId jointId);

  /// <summary>
  /// Create a distance joint
  /// @see b2DistanceJointDef for details
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateDistanceJoint(b2WorldId worldId, in b2DistanceJointDef def);

  /// <summary>
  /// Set the rest length of a distance joint
  /// </summary>
  /// <param name="jointId">The id for a distance joint</param>
  /// <param name="length">The new distance joint length</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetLength(b2JointId jointId, float length);

  /// <summary>
  /// Get the rest length of a distance joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetLength(b2JointId jointId);

  /// <summary>
  /// Enable/disable the distance joint spring. When disabled the distance joint is rigid.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_EnableSpring(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableSpring);

  /// <summary>
  /// Is the distance joint spring enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2DistanceJoint_IsSpringEnabled(b2JointId jointId);

  /// <summary>
  /// Set the spring stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Set the spring damping ratio, non-dimensional
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the spring Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Get the spring damping ratio
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Enable joint limit. The limit only works if the joint spring is enabled. Otherwise the joint is rigid
  /// and the limit has no effect.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_EnableLimit(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableLimit);

  /// <summary>
  /// Is the distance joint limit enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2DistanceJoint_IsLimitEnabled(b2JointId jointId);

  /// <summary>
  /// Set the minimum and maximum length parameters of a distance joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetLengthRange(b2JointId jointId, float minLength, float maxLength);

  /// <summary>
  /// Get the distance joint minimum length
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMinLength(b2JointId jointId);

  /// <summary>
  /// Get the distance joint maximum length
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMaxLength(b2JointId jointId);

  /// <summary>
  /// Get the current length of a distance joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetCurrentLength(b2JointId jointId);

  /// <summary>
  /// Enable/disable the distance joint motor
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_EnableMotor(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableMotor);

  /// <summary>
  /// Is the distance joint motor enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2DistanceJoint_IsMotorEnabled(b2JointId jointId);

  /// <summary>
  /// Set the distance joint motor speed, typically in meters per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);

  /// <summary>
  /// Get the distance joint motor speed, typically in meters per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMotorSpeed(b2JointId jointId);

  /// <summary>
  /// Set the distance joint maximum motor force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetMaxMotorForce(b2JointId jointId, float force);

  /// <summary>
  /// Get the distance joint maximum motor force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMaxMotorForce(b2JointId jointId);

  /// <summary>
  /// Get the distance joint current motor force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMotorForce(b2JointId jointId);

  /// <summary>
  /// Create a motor joint
  /// @see b2MotorJointDef for details
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateMotorJoint(b2WorldId worldId, in b2MotorJointDef def);

  /// <summary>
  /// Set the motor joint linear offset target
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MotorJoint_SetLinearOffset(b2JointId jointId, Vector2 linearOffset);

  /// <summary>
  /// Get the motor joint linear offset target
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2MotorJoint_GetLinearOffset(b2JointId jointId);

  /// <summary>
  /// Set the motor joint angular offset target in radians
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MotorJoint_SetAngularOffset(b2JointId jointId, float angularOffset);

  /// <summary>
  /// Get the motor joint angular offset target in radians
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MotorJoint_GetAngularOffset(b2JointId jointId);

  /// <summary>
  /// Set the motor joint maximum force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MotorJoint_SetMaxForce(b2JointId jointId, float maxForce);

  /// <summary>
  /// Get the motor joint maximum force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MotorJoint_GetMaxForce(b2JointId jointId);

  /// <summary>
  /// Set the motor joint maximum torque, typically in newton-meters
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MotorJoint_SetMaxTorque(b2JointId jointId, float maxTorque);

  /// <summary>
  /// Get the motor joint maximum torque, typically in newton-meters
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MotorJoint_GetMaxTorque(b2JointId jointId);

  /// <summary>
  /// Set the motor joint correction factor, typically in [0, 1]
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MotorJoint_SetCorrectionFactor(b2JointId jointId, float correctionFactor);

  /// <summary>
  /// Get the motor joint correction factor, typically in [0, 1]
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MotorJoint_GetCorrectionFactor(b2JointId jointId);

  /// <summary>
  /// Create a mouse joint
  /// @see b2MouseJointDef for details
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateMouseJoint(b2WorldId worldId, in b2MouseJointDef def);

  /// <summary>
  /// Set the mouse joint target
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MouseJoint_SetTarget(b2JointId jointId, Vector2 target);

  /// <summary>
  /// Get the mouse joint target
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2MouseJoint_GetTarget(b2JointId jointId);

  /// <summary>
  /// Set the mouse joint spring stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MouseJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the mouse joint spring stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MouseJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Set the mouse joint spring damping ratio, non-dimensional
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MouseJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the mouse joint damping ratio, non-dimensional
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MouseJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Set the mouse joint maximum force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MouseJoint_SetMaxForce(b2JointId jointId, float maxForce);

  /// <summary>
  /// Get the mouse joint maximum force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MouseJoint_GetMaxForce(b2JointId jointId);

  /// <summary>
  /// Create a null joint.
  /// @see b2NullJointDef for details
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateNullJoint(b2WorldId worldId, in b2NullJointDef def);

  /// <summary>
  /// Create a prismatic (slider) joint.
  /// @see b2PrismaticJointDef for details
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreatePrismaticJoint(b2WorldId worldId, in b2PrismaticJointDef def);

  /// <summary>
  /// Enable/disable the joint spring.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_EnableSpring(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableSpring);

  /// <summary>
  /// Is the prismatic joint spring enabled or not?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PrismaticJoint_IsSpringEnabled(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint stiffness in Hertz.
  /// This should usually be less than a quarter of the simulation rate. For example, if the simulation
  /// runs at 60Hz then the joint stiffness should be 15Hz or less.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the prismatic joint stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint damping ratio (non-dimensional)
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the prismatic spring damping ratio (non-dimensional)
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Enable/disable a prismatic joint limit
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_EnableLimit(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableLimit);

  /// <summary>
  /// Is the prismatic joint limit enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PrismaticJoint_IsLimitEnabled(b2JointId jointId);

  /// <summary>
  /// Get the prismatic joint lower limit
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetLowerLimit(b2JointId jointId);

  /// <summary>
  /// Get the prismatic joint upper limit
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetUpperLimit(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint limits
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetLimits(b2JointId jointId, float lower, float upper);

  /// <summary>
  /// Enable/disable a prismatic joint motor
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_EnableMotor(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableMotor);

  /// <summary>
  /// Is the prismatic joint motor enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PrismaticJoint_IsMotorEnabled(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint motor speed, typically in meters per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);

  /// <summary>
  /// Get the prismatic joint motor speed, typically in meters per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetMotorSpeed(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint maximum motor force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetMaxMotorForce(b2JointId jointId, float force);

  /// <summary>
  /// Get the prismatic joint maximum motor force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetMaxMotorForce(b2JointId jointId);

  /// <summary>
  /// Get the prismatic joint current motor force, typically in newtons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetMotorForce(b2JointId jointId);

  /// <summary>
  /// Get the current joint translation, usually in meters.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetTranslation(b2JointId jointId);

  /// <summary>
  /// Get the current joint translation speed, usually in meters per second.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetSpeed(b2JointId jointId);

  /// <summary>
  /// Create a revolute joint
  /// @see b2RevoluteJointDef for details
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateRevoluteJoint(b2WorldId worldId, in b2RevoluteJointDef def);

  /// <summary>
  /// Enable/disable the revolute joint spring
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_EnableSpring(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableSpring);

  /// <summary>
  /// It the revolute angular spring enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2RevoluteJoint_IsSpringEnabled(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint spring stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the revolute joint spring stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint spring damping ratio, non-dimensional
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the revolute joint spring damping ratio, non-dimensional
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Get the revolute joint current angle in radians relative to the reference angle
  /// @see b2RevoluteJointDef::referenceAngle
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetAngle(b2JointId jointId);

  /// <summary>
  /// Enable/disable the revolute joint limit
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_EnableLimit(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableLimit);

  /// <summary>
  /// Is the revolute joint limit enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2RevoluteJoint_IsLimitEnabled(b2JointId jointId);

  /// <summary>
  /// Get the revolute joint lower limit in radians
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetLowerLimit(b2JointId jointId);

  /// <summary>
  /// Get the revolute joint upper limit in radians
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetUpperLimit(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint limits in radians
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetLimits(b2JointId jointId, float lower, float upper);

  /// <summary>
  /// Enable/disable a revolute joint motor
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_EnableMotor(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableMotor);

  /// <summary>
  /// Is the revolute joint motor enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2RevoluteJoint_IsMotorEnabled(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint motor speed in radians per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);

  /// <summary>
  /// Get the revolute joint motor speed in radians per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetMotorSpeed(b2JointId jointId);

  /// <summary>
  /// Get the revolute joint current motor torque, typically in newton-meters
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetMotorTorque(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint maximum motor torque, typically in newton-meters
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetMaxMotorTorque(b2JointId jointId, float torque);

  /// <summary>
  /// Get the revolute joint maximum motor torque, typically in newton-meters
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetMaxMotorTorque(b2JointId jointId);

  /// <summary>
  /// Create a weld joint
  /// @see b2WeldJointDef for details
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateWeldJoint(b2WorldId worldId, in b2WeldJointDef def);

  /// <summary>
  /// Get the weld joint reference angle in radians
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WeldJoint_GetReferenceAngle(b2JointId jointId);

  /// <summary>
  /// Set the weld joint reference angle in radians, must be in [-pi,pi].
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WeldJoint_SetReferenceAngle(b2JointId jointId, float angleInRadians);

  /// <summary>
  /// Set the weld joint linear stiffness in Hertz. 0 is rigid.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WeldJoint_SetLinearHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the weld joint linear stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WeldJoint_GetLinearHertz(b2JointId jointId);

  /// <summary>
  /// Set the weld joint linear damping ratio (non-dimensional)
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WeldJoint_SetLinearDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the weld joint linear damping ratio (non-dimensional)
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WeldJoint_GetLinearDampingRatio(b2JointId jointId);

  /// <summary>
  /// Set the weld joint angular stiffness in Hertz. 0 is rigid.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WeldJoint_SetAngularHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the weld joint angular stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WeldJoint_GetAngularHertz(b2JointId jointId);

  /// <summary>
  /// Set weld joint angular damping ratio, non-dimensional
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WeldJoint_SetAngularDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the weld joint angular damping ratio, non-dimensional
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WeldJoint_GetAngularDampingRatio(b2JointId jointId);

  /// <summary>
  /// Create a wheel joint
  /// @see b2WheelJointDef for details
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateWheelJoint(b2WorldId worldId, in b2WheelJointDef def);

  /// <summary>
  /// Enable/disable the wheel joint spring
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_EnableSpring(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableSpring);

  /// <summary>
  /// Is the wheel joint spring enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2WheelJoint_IsSpringEnabled(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the wheel joint stiffness in Hertz
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint damping ratio, non-dimensional
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the wheel joint damping ratio, non-dimensional
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Enable/disable the wheel joint limit
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_EnableLimit(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableLimit);

  /// <summary>
  /// Is the wheel joint limit enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2WheelJoint_IsLimitEnabled(b2JointId jointId);

  /// <summary>
  /// Get the wheel joint lower limit
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetLowerLimit(b2JointId jointId);

  /// <summary>
  /// Get the wheel joint upper limit
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetUpperLimit(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint limits
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetLimits(b2JointId jointId, float lower, float upper);

  /// <summary>
  /// Enable/disable the wheel joint motor
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_EnableMotor(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableMotor);

  /// <summary>
  /// Is the wheel joint motor enabled?
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2WheelJoint_IsMotorEnabled(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint motor speed in radians per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);

  /// <summary>
  /// Get the wheel joint motor speed in radians per second
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetMotorSpeed(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint maximum motor torque, typically in newton-meters
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetMaxMotorTorque(b2JointId jointId, float torque);

  /// <summary>
  /// Get the wheel joint maximum motor torque, typically in newton-meters
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetMaxMotorTorque(b2JointId jointId);

  /// <summary>
  /// Get the wheel joint current motor torque, typically in newton-meters
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetMotorTorque(b2JointId jointId);

  /// <summary>
  /// Validate ray cast input data (NaN, etc)
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2IsValidRay(in b2RayCastInput input);

  /// <summary>
  /// Make a convex polygon from a convex hull. This will assert if the hull is not valid.
  /// @warning Do not manually fill in the hull data, it must come directly from b2ComputeHull
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakePolygon(in b2Hull hull, float radius);

  /// <summary>
  /// Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.
  /// @warning Do not manually fill in the hull data, it must come directly from b2ComputeHull
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeOffsetPolygon(in b2Hull hull, Vector2 position, b2Rot rotation);

  /// <summary>
  /// Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.
  /// @warning Do not manually fill in the hull data, it must come directly from b2ComputeHull
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeOffsetRoundedPolygon(in b2Hull hull, Vector2 position, b2Rot rotation, float radius);

  /// <summary>
  /// Make a square polygon, bypassing the need for a convex hull.
  /// </summary>
  /// <param name="h">the half-width</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeSquare(float h);

  /// <summary>
  /// Make a box (rectangle) polygon, bypassing the need for a convex hull.
  /// </summary>
  /// <param name="hx">the half-width</param>
  /// <param name="hy">the half-height</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeBox(float hx, float hy);

  /// <summary>
  /// Make a rounded box, bypassing the need for a convex hull.
  /// </summary>
  /// <param name="hx">the half-width</param>
  /// <param name="hy">the half-height</param>
  /// <param name="radius">the radius of the rounded extension</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeRoundedBox(float hx, float hy, float radius);

  /// <summary>
  /// Make an offset box, bypassing the need for a convex hull.
  /// </summary>
  /// <param name="hx">the half-width</param>
  /// <param name="hy">the half-height</param>
  /// <param name="center">the local center of the box</param>
  /// <param name="rotation">the local rotation of the box</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeOffsetBox(float hx, float hy, Vector2 center, b2Rot rotation);

  /// <summary>
  /// Make an offset rounded box, bypassing the need for a convex hull.
  /// </summary>
  /// <param name="hx">the half-width</param>
  /// <param name="hy">the half-height</param>
  /// <param name="center">the local center of the box</param>
  /// <param name="rotation">the local rotation of the box</param>
  /// <param name="radius">the radius of the rounded extension</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeOffsetRoundedBox(float hx, float hy, Vector2 center, b2Rot rotation, float radius);

  /// <summary>
  /// Transform a polygon. This is useful for transferring a shape from one body to another.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2TransformPolygon(b2Transform transform, in b2Polygon polygon);

  /// <summary>
  /// Compute mass properties of a circle
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MassData b2ComputeCircleMass(in b2Circle shape, float density);

  /// <summary>
  /// Compute mass properties of a capsule
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MassData b2ComputeCapsuleMass(in b2Capsule shape, float density);

  /// <summary>
  /// Compute mass properties of a polygon
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MassData b2ComputePolygonMass(in b2Polygon shape, float density);

  /// <summary>
  /// Compute the bounding box of a transformed circle
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2ComputeCircleAABB(in b2Circle shape, b2Transform transform);

  /// <summary>
  /// Compute the bounding box of a transformed capsule
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2ComputeCapsuleAABB(in b2Capsule shape, b2Transform transform);

  /// <summary>
  /// Compute the bounding box of a transformed polygon
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2ComputePolygonAABB(in b2Polygon shape, b2Transform transform);

  /// <summary>
  /// Compute the bounding box of a transformed line segment
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2ComputeSegmentAABB(in b2Segment shape, b2Transform transform);

  /// <summary>
  /// Test a point for overlap with a circle in local space
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PointInCircle(Vector2 point, in b2Circle shape);

  /// <summary>
  /// Test a point for overlap with a capsule in local space
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PointInCapsule(Vector2 point, in b2Capsule shape);

  /// <summary>
  /// Test a point for overlap with a convex polygon in local space
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PointInPolygon(Vector2 point, in b2Polygon shape);

  /// <summary>
  /// Ray cast versus circle shape in local space. Initial overlap is treated as a miss.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2RayCastCircle(in b2RayCastInput input, in b2Circle shape);

  /// <summary>
  /// Ray cast versus capsule shape in local space. Initial overlap is treated as a miss.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2RayCastCapsule(in b2RayCastInput input, in b2Capsule shape);

  /// <summary>
  /// Ray cast versus segment shape in local space. Optionally treat the segment as one-sided with hits from
  /// the left side being treated as a miss.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2RayCastSegment(in b2RayCastInput input, in b2Segment shape, [MarshalAs(UnmanagedType.U1)] bool oneSided);

  /// <summary>
  /// Ray cast versus polygon shape in local space. Initial overlap is treated as a miss.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2RayCastPolygon(in b2RayCastInput input, in b2Polygon shape);

  /// <summary>
  /// Shape cast versus a circle. Initial overlap is treated as a miss.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCastCircle(in b2ShapeCastInput input, in b2Circle shape);

  /// <summary>
  /// Shape cast versus a capsule. Initial overlap is treated as a miss.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCastCapsule(in b2ShapeCastInput input, in b2Capsule shape);

  /// <summary>
  /// Shape cast versus a line segment. Initial overlap is treated as a miss.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCastSegment(in b2ShapeCastInput input, in b2Segment shape);

  /// <summary>
  /// Shape cast versus a convex polygon. Initial overlap is treated as a miss.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCastPolygon(in b2ShapeCastInput input, in b2Polygon shape);

  /// <summary>
  /// Compute the convex hull of a set of points. Returns an empty hull if it fails.
  /// Some failure cases:
  /// - all points very close together
  /// - all points on a line
  /// - less than 3 points
  /// - more than b2_maxPolygonVertices points
  /// This welds close points and removes collinear points.
  /// @warning Do not modify a hull once it has been computed
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Hull b2ComputeHull(Vector2[] /* const b2Vec2* */ points, int count);

  /// <summary>
  /// This determines if a hull is valid. Checks for:
  /// - convexity
  /// - collinear points
  /// This is expensive and should not be called at runtime.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2ValidateHull(in b2Hull hull);

  /// <summary>
  /// Compute the distance between two line segments, clamping at the end points if needed.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2SegmentDistanceResult b2SegmentDistance(Vector2 p1, Vector2 q1, Vector2 p2, Vector2 q2);

  /// <summary>
  /// Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and translation fraction.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCast(in b2ShapeCastPairInput input);

  /// <summary>
  /// Make a proxy for use in GJK and related functions.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2DistanceProxy b2MakeProxy(Vector2[] /* const b2Vec2* */ vertices, int count, float radius);

  /// <summary>
  /// Evaluate the transform sweep at a specific time.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Transform b2GetSweepTransform(in b2Sweep sweep, float time);

  /// <summary>
  /// Compute the upper bound on time before two shapes penetrate. Time is represented as
  /// a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
  /// non-tunneling collisions. If you change the time interval, you should call this function
  /// again.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TOIOutput b2TimeOfImpact(in b2TOIInput input);

  /// <summary>
  /// Compute the contact manifold between two circles
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideCircles(in b2Circle circleA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a capsule and circle
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideCapsuleAndCircle(in b2Capsule capsuleA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between an segment and a circle
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideSegmentAndCircle(in b2Segment segmentA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a polygon and a circle
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollidePolygonAndCircle(in b2Polygon polygonA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a capsule and circle
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideCapsules(in b2Capsule capsuleA, b2Transform xfA, in b2Capsule capsuleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between an segment and a capsule
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideSegmentAndCapsule(in b2Segment segmentA, b2Transform xfA, in b2Capsule capsuleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a polygon and capsule
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollidePolygonAndCapsule(in b2Polygon polygonA, b2Transform xfA, in b2Capsule capsuleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between two polygons
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollidePolygons(in b2Polygon polygonA, b2Transform xfA, in b2Polygon polygonB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between an segment and a polygon
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideSegmentAndPolygon(in b2Segment segmentA, b2Transform xfA, in b2Polygon polygonB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a chain segment and a circle
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideChainSegmentAndCircle(in b2ChainSegment segmentA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute an approximate arctangent in the range [-pi, pi]
  /// This is hand coded for cross platform determinism. The atan2f
  /// function in the standard library is not cross platform deterministic.
  /// Accurate to around 0.0023 degrees
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Atan2(float y, float x);

  /// <summary>
  /// Make a rotation using an angle in radians
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CosSin b2ComputeCosSin(float angle);

  /// <summary>
  /// Compute the rotation between two unit vectors
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Rot b2ComputeRotationBetweenUnitVectors(Vector2 v1, Vector2 v2);

  /// <summary>
  /// Is this a valid number? Not NaN or infinity.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Float_IsValid(float a);

  /// <summary>
  /// Is this a valid vector? Not NaN or infinity.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Vec2_IsValid(Vector2 v);

  /// <summary>
  /// Is this a valid rotation? Not NaN or infinity. Is normalized.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Rot_IsValid(b2Rot q);

  /// <summary>
  /// Is this a valid bounding box? Not Nan or infinity. Upper bound greater than or equal to lower bound.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2AABB_IsValid(b2AABB aabb);

  /// <summary>
  /// Box2D bases all length units on meters, but you may need different units for your game.
  /// You can set this value to use different units. This should be done at application startup
  /// and only modified once. Default value is 1.
  /// @warning This must be modified before any calls to Box2D
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2SetLengthUnitsPerMeter(float lengthUnits);

  /// <summary>
  /// Get the current length units per meter.
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2GetLengthUnitsPerMeter();

  /// <summary>
  /// Use this to initialize your world definition
  /// @ingroup world
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldDef b2DefaultWorldDef();

  /// <summary>
  /// Use this to initialize your body definition
  /// @ingroup body
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyDef b2DefaultBodyDef();

  /// <summary>
  /// Use this to initialize your filter
  /// @ingroup shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Filter b2DefaultFilter();

  /// <summary>
  /// Use this to initialize your query filter
  /// @ingroup shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2QueryFilter b2DefaultQueryFilter();

  /// <summary>
  /// Use this to initialize your shape definition
  /// @ingroup shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeDef b2DefaultShapeDef();

  /// <summary>
  /// Use this to initialize your chain definition
  /// @ingroup shape
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ChainDef b2DefaultChainDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup distance_joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2DistanceJointDef b2DefaultDistanceJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup motor_joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MotorJointDef b2DefaultMotorJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup mouse_joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MouseJointDef b2DefaultMouseJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup null_joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2NullJointDef b2DefaultNullJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroupd prismatic_joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2PrismaticJointDef b2DefaultPrismaticJointDef();

  /// <summary>
  /// Use this to initialize your joint definition.
  /// @ingroup revolute_joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2RevoluteJointDef b2DefaultRevoluteJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup weld_joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WeldJointDef b2DefaultWeldJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup wheel_joint
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WheelJointDef b2DefaultWheelJointDef();

  /// <summary>
  /// Use this to initialize your explosion definition
  /// @ingroup world
  /// </summary>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ExplosionDef b2DefaultExplosionDef();

    }
}
